import {
  B,
  G,
  O,
  P,
  _,
  a,
  g,
  l,
  p,
  y
} from "./chunk-7K4KILFW.js";

// node_modules/@schedule-x/calendar/dist/core.js
var f = 0;
function u(e, t, n, o, i, u2) {
  var a2, c, p2 = {};
  for (c in t)
    "ref" == c ? a2 = t[c] : p2[c] = t[c];
  var l2 = { type: e, props: p2, key: n, ref: a2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: --f, __i: -1, __u: 0, __source: i, __self: u2 };
  if ("function" == typeof e && (a2 = e.defaultProps))
    for (c in a2)
      void 0 === p2[c] && (p2[c] = a2[c]);
  return l.vnode && l.vnode(l2), l2;
}
var AppContext$1 = G({});
var DateFormats = {
  DATE_STRING: /^\d{4}-\d{2}-\d{2}$/,
  TIME_STRING: /^\d{2}:\d{2}$/,
  DATE_TIME_STRING: /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/
};
var InvalidDateTimeError = class extends Error {
  constructor(dateTimeSpecification) {
    super(`Invalid date time specification: ${dateTimeSpecification}`);
  }
};
var toJSDate = (dateTimeSpecification) => {
  if (!DateFormats.DATE_TIME_STRING.test(dateTimeSpecification) && !DateFormats.DATE_STRING.test(dateTimeSpecification))
    throw new InvalidDateTimeError(dateTimeSpecification);
  return new Date(
    Number(dateTimeSpecification.slice(0, 4)),
    Number(dateTimeSpecification.slice(5, 7)) - 1,
    Number(dateTimeSpecification.slice(8, 10)),
    Number(dateTimeSpecification.slice(11, 13)),
    // for date strings this will be 0
    Number(dateTimeSpecification.slice(14, 16))
    // for date strings this will be 0
  );
};
var toIntegers = (dateTimeSpecification) => {
  const hours = dateTimeSpecification.slice(11, 13), minutes = dateTimeSpecification.slice(14, 16);
  return {
    year: Number(dateTimeSpecification.slice(0, 4)),
    month: Number(dateTimeSpecification.slice(5, 7)) - 1,
    date: Number(dateTimeSpecification.slice(8, 10)),
    hours: hours !== "" ? Number(hours) : void 0,
    minutes: minutes !== "" ? Number(minutes) : void 0
  };
};
var toLocalizedMonth = (date, locale) => {
  return date.toLocaleString(locale, { month: "long" });
};
var toLocalizedDateString = (date, locale) => {
  return date.toLocaleString(locale, {
    month: "numeric",
    day: "numeric",
    year: "numeric"
  });
};
var getOneLetterDayNames = (week, locale) => {
  return week.map((date) => {
    return date.toLocaleString(locale, { weekday: "short" }).charAt(0);
  });
};
var getDayNameShort = (date, locale) => date.toLocaleString(locale, { weekday: "short" });
var getDayNamesShort = (week, locale) => {
  return week.map((date) => getDayNameShort(date, locale));
};
var getOneLetterOrShortDayNames = (week, locale) => {
  if (["zh-cn"].includes(locale.toLowerCase())) {
    return getDayNamesShort(week, locale);
  }
  return getOneLetterDayNames(week, locale);
};
var img = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='utf-8'%3f%3e%3c!-- Uploaded to: SVG Repo%2c www.svgrepo.com%2c Generator: SVG Repo Mixer Tools --%3e%3csvg width='800px' height='800px' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M6 9L12 15L18 9' stroke='%23DED8E1' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'/%3e%3c/svg%3e";
var randomStringId = () => "s" + Math.random().toString(36).substring(2, 11);
var isKeyEnterOrSpace = (keyboardEvent) => keyboardEvent.key === "Enter" || keyboardEvent.key === " ";
function AppInput() {
  const datePickerInputId = randomStringId();
  const datePickerLabelId = randomStringId();
  const $app = P(AppContext$1);
  const getLocalizedDate2 = (dateString) => {
    if (dateString === "")
      return $app.translate("MM/DD/YYYY");
    return toLocalizedDateString(toJSDate(dateString), $app.config.locale);
  };
  _(() => {
    $app.datePickerState.inputDisplayedValue.value = getLocalizedDate2($app.datePickerState.selectedDate.value);
  }, [$app.datePickerState.selectedDate.value]);
  const [wrapperClasses, setWrapperClasses] = p([]);
  _(() => {
    const newClasses = ["sx__date-input-wrapper"];
    if ($app.datePickerState.isOpen.value)
      newClasses.push("sx__date-input--active");
    setWrapperClasses(newClasses);
  }, [$app.datePickerState.isOpen.value]);
  const handleKeyUp = (event) => {
    if (event.key === "Enter")
      handleInputValue(event);
  };
  const handleInputValue = (event) => {
    event.stopPropagation();
    try {
      $app.datePickerState.inputDisplayedValue.value = event.target.value;
      $app.datePickerState.close();
    } catch (e) {
    }
  };
  _(() => {
    const inputElement = document.getElementById(datePickerInputId);
    if (inputElement === null)
      return;
    inputElement.addEventListener("change", handleInputValue);
    return () => inputElement.removeEventListener("change", handleInputValue);
  });
  const handleClick = (event) => {
    handleInputValue(event);
    $app.datePickerState.open();
  };
  const handleButtonKeyDown = (keyboardEvent) => {
    if (isKeyEnterOrSpace(keyboardEvent)) {
      keyboardEvent.preventDefault();
      $app.datePickerState.open();
      setTimeout(() => {
        const element = document.querySelector('[data-focus="true"]');
        if (element instanceof HTMLElement)
          element.focus();
      }, 50);
    }
  };
  return u(g, { children: u("div", { className: wrapperClasses.join(" "), children: [u("label", { for: datePickerInputId, id: datePickerLabelId, className: "sx__date-input-label", children: $app.translate("Date") }), u("input", { id: datePickerInputId, "aria-describedby": datePickerLabelId, value: $app.datePickerState.inputDisplayedValue.value, "data-testid": "date-picker-input", className: "sx__date-input", onClick: handleClick, onKeyUp: handleKeyUp, type: "text" }), u("button", { "aria-label": $app.translate("Choose Date"), onKeyDown: handleButtonKeyDown, className: "sx__date-input-chevron-wrapper", children: u("img", { className: "sx__date-input-chevron", src: img, alt: "" }) })] }) });
}
var DatePickerView;
(function(DatePickerView2) {
  DatePickerView2["MONTH_DAYS"] = "month-days";
  DatePickerView2["YEARS"] = "years";
})(DatePickerView || (DatePickerView = {}));
var YEARS_VIEW = "years-view";
var MONTH_VIEW = "months-view";
var DATE_PICKER_WEEK = "date-picker-week";
var NumberRangeError = class extends Error {
  constructor(min, max) {
    super(`Number must be between ${min} and ${max}.`);
    Object.defineProperty(this, "min", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: min
    });
    Object.defineProperty(this, "max", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: max
    });
  }
};
var doubleDigit = (number) => {
  if (number < 0 || number > 99)
    throw new NumberRangeError(0, 99);
  return String(number).padStart(2, "0");
};
var toDateString$1 = (date) => {
  return `${date.getFullYear()}-${doubleDigit(date.getMonth() + 1)}-${doubleDigit(date.getDate())}`;
};
var toTimeString = (date) => {
  return `${doubleDigit(date.getHours())}:${doubleDigit(date.getMinutes())}`;
};
var toDateTimeString = (date) => {
  return `${toDateString$1(date)} ${toTimeString(date)}`;
};
var addMonths = (to, nMonths) => {
  const { year, month, date, hours, minutes } = toIntegers(to);
  const isDateTimeString = hours !== void 0 && minutes !== void 0;
  const jsDate = new Date(year, month, date, hours !== null && hours !== void 0 ? hours : 0, minutes !== null && minutes !== void 0 ? minutes : 0);
  jsDate.setMonth(jsDate.getMonth() + nMonths);
  if (isDateTimeString) {
    return toDateTimeString(jsDate);
  }
  return toDateString$1(jsDate);
};
var addDays = (to, nDays) => {
  const { year, month, date, hours, minutes } = toIntegers(to);
  const isDateTimeString = hours !== void 0 && minutes !== void 0;
  const jsDate = new Date(year, month, date, hours !== null && hours !== void 0 ? hours : 0, minutes !== null && minutes !== void 0 ? minutes : 0);
  jsDate.setDate(jsDate.getDate() + nDays);
  if (isDateTimeString) {
    return toDateTimeString(jsDate);
  }
  return toDateString$1(jsDate);
};
var dateFromDateTime = (dateTime) => {
  return dateTime.slice(0, 10);
};
var timeFromDateTime = (dateTime) => {
  return dateTime.slice(11);
};
var setDateOfMonth = (dateString, date) => {
  dateString = dateString.slice(0, 8) + doubleDigit(date) + dateString.slice(10);
  return dateString;
};
var getFirstDayOPreviousMonth = (dateString) => {
  dateString = addMonths(dateString, -1);
  return setDateOfMonth(dateString, 1);
};
var getFirstDayOfNextMonth = (dateString) => {
  dateString = addMonths(dateString, 1);
  return setDateOfMonth(dateString, 1);
};
var setTimeInDateTimeString = (dateTimeString, newTime) => {
  const dateCache = toDateString$1(toJSDate(dateTimeString));
  return `${dateCache} ${newTime}`;
};
function Chevron({ direction, onClick, buttonText }) {
  const handleKeyDown = (keyboardEvent) => {
    if (isKeyEnterOrSpace(keyboardEvent))
      onClick();
  };
  return u("button", { className: "sx__chevron-wrapper sx__ripple", onMouseUp: onClick, onKeyDown: handleKeyDown, tabIndex: 0, children: u("i", { className: `sx__chevron sx__chevron--${direction}`, children: buttonText }) });
}
function MonthViewHeader({ setYearsView }) {
  const $app = P(AppContext$1);
  const dateStringToLocalizedMonthName = (selectedDate) => {
    const selectedDateJS = toJSDate(selectedDate);
    return toLocalizedMonth(selectedDateJS, $app.config.locale);
  };
  const getYearFrom = (datePickerDate) => {
    return toIntegers(datePickerDate).year;
  };
  const [selectedDateMonthName, setSelectedDateMonthName] = p(dateStringToLocalizedMonthName($app.datePickerState.datePickerDate.value));
  const [datePickerYear, setDatePickerYear] = p(getYearFrom($app.datePickerState.datePickerDate.value));
  const setPreviousMonth = () => {
    $app.datePickerState.datePickerDate.value = getFirstDayOPreviousMonth($app.datePickerState.datePickerDate.value);
  };
  const setNextMonth = () => {
    $app.datePickerState.datePickerDate.value = getFirstDayOfNextMonth($app.datePickerState.datePickerDate.value);
  };
  _(() => {
    setSelectedDateMonthName(dateStringToLocalizedMonthName($app.datePickerState.datePickerDate.value));
    setDatePickerYear(getYearFrom($app.datePickerState.datePickerDate.value));
  }, [$app.datePickerState.datePickerDate.value]);
  const handleOpenYearsView = (e) => {
    e.stopPropagation();
    setYearsView();
  };
  return u(g, { children: u("header", { className: "sx__date-picker__month-view-header", children: [u(Chevron, { direction: "previous", onClick: () => setPreviousMonth(), buttonText: $app.translate("Previous month") }), u("button", { className: "sx__date-picker__month-view-header__month-year", onClick: (event) => handleOpenYearsView(event), children: selectedDateMonthName + " " + datePickerYear }), u(Chevron, { direction: "next", onClick: () => setNextMonth(), buttonText: $app.translate("Next month") })] }) });
}
function DayNames() {
  const $app = P(AppContext$1);
  const aWeek = $app.timeUnitsImpl.getWeekFor(toJSDate($app.datePickerState.datePickerDate.value));
  const dayNames = getOneLetterOrShortDayNames(aWeek, $app.config.locale);
  return u("div", { className: "sx__date-picker__day-names", children: dayNames.map((dayName) => u("span", { "data-testid": "day-name", className: "sx__date-picker__day-name", children: dayName })) });
}
var isToday = (date) => {
  const today = /* @__PURE__ */ new Date();
  return date.getDate() === today.getDate() && date.getMonth() === today.getMonth() && date.getFullYear() === today.getFullYear();
};
var isSameMonth = (date1, date2) => {
  return date1.getMonth() === date2.getMonth() && date1.getFullYear() === date2.getFullYear();
};
var dateFn = (dateTimeString, locale) => {
  const { year, month, date } = toIntegers(dateTimeString);
  return new Date(year, month, date).toLocaleDateString(locale, {
    day: "numeric",
    month: "long",
    year: "numeric"
  });
};
var getLocalizedDate = dateFn;
var timeFn = (dateTimeString, locale) => {
  const { year, month, date, hours, minutes } = toIntegers(dateTimeString);
  return new Date(year, month, date, hours, minutes).toLocaleTimeString(locale, {
    hour: "numeric",
    minute: "numeric"
  });
};
var getTimeStamp = (calendarEvent, locale, delimiter = "–") => {
  const eventTime = { start: calendarEvent.start, end: calendarEvent.end };
  if (calendarEvent._isSingleDayFullDay) {
    return dateFn(eventTime.start, locale);
  }
  if (calendarEvent._isMultiDayFullDay) {
    return `${dateFn(eventTime.start, locale)} ${delimiter} ${dateFn(eventTime.end, locale)}`;
  }
  if (calendarEvent._isSingleDayTimed) {
    return `${dateFn(eventTime.start, locale)} ⋅ ${timeFn(eventTime.start, locale)} ${delimiter} ${timeFn(eventTime.end, locale)}`;
  }
  return `${dateFn(eventTime.start, locale)}, ${timeFn(eventTime.start, locale)} ${delimiter} ${dateFn(eventTime.end, locale)}, ${timeFn(eventTime.end, locale)}`;
};
function MonthViewWeek({ week }) {
  const $app = P(AppContext$1);
  const weekDays = week.map((day) => {
    const classes = ["sx__date-picker__day"];
    if (isToday(day))
      classes.push("sx__date-picker__day--today");
    if (toDateString$1(day) === $app.datePickerState.selectedDate.value)
      classes.push("sx__date-picker__day--selected");
    if (!isSameMonth(day, toJSDate($app.datePickerState.datePickerDate.value)))
      classes.push("is-leading-or-trailing");
    return {
      day,
      classes
    };
  });
  const isDateSelectable = (date) => {
    const dateString = toDateString$1(date);
    return dateString >= $app.config.min && dateString <= $app.config.max;
  };
  const selectDate = (date) => {
    $app.datePickerState.selectedDate.value = toDateString$1(date);
    $app.datePickerState.close();
  };
  const hasFocus = (weekDay) => toDateString$1(weekDay.day) === $app.datePickerState.datePickerDate.value;
  const handleKeyDown = (event) => {
    if (event.key === "Enter") {
      $app.datePickerState.selectedDate.value = $app.datePickerState.datePickerDate.value;
      $app.datePickerState.close();
      return;
    }
    const keyMapDaysToAdd = /* @__PURE__ */ new Map([
      ["ArrowDown", 7],
      ["ArrowUp", -7],
      ["ArrowLeft", -1],
      ["ArrowRight", 1]
    ]);
    $app.datePickerState.datePickerDate.value = addDays($app.datePickerState.datePickerDate.value, keyMapDaysToAdd.get(event.key) || 0);
  };
  return u(g, { children: u("div", { "data-testid": DATE_PICKER_WEEK, className: "sx__date-picker__week", children: weekDays.map((weekDay) => u("button", { tabIndex: hasFocus(weekDay) ? 0 : -1, disabled: !isDateSelectable(weekDay.day), "aria-label": getLocalizedDate($app.datePickerState.datePickerDate.value, $app.config.locale), className: weekDay.classes.join(" "), "data-focus": hasFocus(weekDay) ? "true" : void 0, onClick: () => selectDate(weekDay.day), onKeyDown: handleKeyDown, children: weekDay.day.getDate() })) }) });
}
function MonthView({ seatYearsView }) {
  const elementId = randomStringId();
  const $app = P(AppContext$1);
  const [month, setMonth] = p([]);
  const renderMonth = () => {
    const newDatePickerDate = toJSDate($app.datePickerState.datePickerDate.value);
    setMonth($app.timeUnitsImpl.getMonthWithTrailingAndLeadingDays(newDatePickerDate.getFullYear(), newDatePickerDate.getMonth()));
  };
  _(() => {
    renderMonth();
  }, [$app.datePickerState.datePickerDate.value]);
  _(() => {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        const mutatedElement = mutation.target;
        if (mutatedElement.dataset.focus === "true")
          mutatedElement.focus();
      });
    });
    const monthViewElement = document.getElementById(elementId);
    observer.observe(monthViewElement, {
      childList: true,
      subtree: true,
      attributes: true
    });
    return () => observer.disconnect();
  }, []);
  return u(g, { children: u("div", { id: elementId, "data-testid": MONTH_VIEW, className: "sx__date-picker__month-view", children: [u(MonthViewHeader, { setYearsView: seatYearsView }), u(DayNames, {}), month.map((week) => u(MonthViewWeek, { week }))] }) });
}
function YearsViewAccordion({ year, setYearAndMonth, isExpanded, expand }) {
  const $app = P(AppContext$1);
  const yearWithDates = $app.timeUnitsImpl.getMonthsFor(year);
  const handleClickOnMonth = (event, month) => {
    event.stopPropagation();
    setYearAndMonth(year, month.getMonth());
  };
  return u(g, { children: u("li", { className: isExpanded ? "sx__is-expanded" : "", children: [u("button", { className: "sx__date-picker__years-accordion__expand-button sx__ripple--wide", onClick: () => expand(year), children: year }), isExpanded && u("div", { className: "sx__date-picker__years-view-accordion__panel", children: yearWithDates.map((month) => u("button", { className: "sx__date-picker__years-view-accordion__month", onClick: (event) => handleClickOnMonth(event, month), children: toLocalizedMonth(month, $app.config.locale) })) })] }) });
}
function YearsView({ setMonthView }) {
  const $app = P(AppContext$1);
  const minYear = toJSDate($app.config.min).getFullYear();
  const maxYear = toJSDate($app.config.max).getFullYear();
  const years = Array.from({ length: maxYear - minYear + 1 }, (_2, i) => minYear + i);
  const { year: selectedYear } = toIntegers($app.datePickerState.selectedDate.value);
  const [expandedYear, setExpandedYear] = p(selectedYear);
  const setNewDatePickerDate = (year, month) => {
    $app.datePickerState.datePickerDate.value = toDateString$1(new Date(year, month, 1));
    setMonthView();
  };
  _(() => {
    var _a;
    const initiallyExpandedYear = (_a = document.querySelector(".sx__date-picker__years-view")) === null || _a === void 0 ? void 0 : _a.querySelector(".sx__is-expanded");
    if (!initiallyExpandedYear)
      return;
    initiallyExpandedYear.scrollIntoView({
      block: "center"
    });
  }, []);
  return u(g, { children: u("ul", { className: "sx__date-picker__years-view", "data-testid": YEARS_VIEW, children: years.map((year) => u(YearsViewAccordion, { year, setYearAndMonth: (year2, month) => setNewDatePickerDate(year2, month), isExpanded: expandedYear === year, expand: (year2) => setExpandedYear(year2) })) }) });
}
var POPUP_CLASS_NAME = "sx__date-picker-popup";
function AppPopup() {
  const $app = P(AppContext$1);
  const [datePickerView, setDatePickerView] = p(DatePickerView.MONTH_DAYS);
  const popupClasses = [POPUP_CLASS_NAME, $app.config.placement];
  const clickOutsideListener = (event) => {
    const target = event.target;
    if (!target.closest(`.${POPUP_CLASS_NAME}`))
      $app.datePickerState.close();
  };
  _(() => {
    document.addEventListener("click", clickOutsideListener);
    return () => document.removeEventListener("click", clickOutsideListener);
  }, []);
  return u(g, { children: u("div", { "data-testid": "date-picker-popup", className: popupClasses.join(" "), children: datePickerView === DatePickerView.MONTH_DAYS ? u(MonthView, { seatYearsView: () => setDatePickerView(DatePickerView.YEARS) }) : u(YearsView, { setMonthView: () => setDatePickerView(DatePickerView.MONTH_DAYS) }) }) });
}
function AppWrapper({ $app }) {
  var _a, _b;
  const classes = ["sx__date-picker-wrapper"];
  if ((_a = $app.config.style) === null || _a === void 0 ? void 0 : _a.dark)
    classes.push("is-dark");
  if ((_b = $app.config.style) === null || _b === void 0 ? void 0 : _b.fullWidth)
    classes.push("has-full-width");
  return u(g, { children: u("div", { className: classes.join(" "), children: u(AppContext$1.Provider, { value: $app, children: [u(AppInput, {}), $app.datePickerState.isOpen.value && u(AppPopup, {})] }) }) });
}
var AppContext = G({});
var DatePickerAppSingletonImpl = class {
  constructor(datePickerState, config, timeUnitsImpl, translate2) {
    Object.defineProperty(this, "datePickerState", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: datePickerState
    });
    Object.defineProperty(this, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: config
    });
    Object.defineProperty(this, "timeUnitsImpl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: timeUnitsImpl
    });
    Object.defineProperty(this, "translate", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: translate2
    });
  }
};
var DatePickerAppSingletonBuilder = class {
  constructor() {
    Object.defineProperty(this, "datePickerState", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "timeUnitsImpl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "translate", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  build() {
    return new DatePickerAppSingletonImpl(this.datePickerState, this.config, this.timeUnitsImpl, this.translate);
  }
  withDatePickerState(datePickerState) {
    this.datePickerState = datePickerState;
    return this;
  }
  withConfig(config) {
    this.config = config;
    return this;
  }
  withTimeUnitsImpl(timeUnitsImpl) {
    this.timeUnitsImpl = timeUnitsImpl;
    return this;
  }
  withTranslate(translate2) {
    this.translate = translate2;
    return this;
  }
};
var InternalViewName;
(function(InternalViewName2) {
  InternalViewName2["Day"] = "day";
  InternalViewName2["Week"] = "week";
  InternalViewName2["MonthGrid"] = "month-grid";
  InternalViewName2["MonthAgenda"] = "month-agenda";
})(InternalViewName || (InternalViewName = {}));
var getLocaleStringMonthArgs = ($app) => {
  return [$app.config.locale, { month: "long" }];
};
var getLocaleStringYearArgs = ($app) => {
  return [$app.config.locale, { year: "numeric" }];
};
var getMonthAndYearForDateRange = ($app, rangeStart, rangeEnd) => {
  const startDateMonth = toJSDate(rangeStart).toLocaleString(...getLocaleStringMonthArgs($app));
  const startDateYear = toJSDate(rangeStart).toLocaleString(...getLocaleStringYearArgs($app));
  const endDateMonth = toJSDate(rangeEnd).toLocaleString(...getLocaleStringMonthArgs($app));
  const endDateYear = toJSDate(rangeEnd).toLocaleString(...getLocaleStringYearArgs($app));
  if (startDateMonth === endDateMonth && startDateYear === endDateYear) {
    return `${startDateMonth} ${startDateYear}`;
  } else if (startDateMonth !== endDateMonth && startDateYear === endDateYear) {
    return `${startDateMonth} – ${endDateMonth} ${startDateYear}`;
  }
  return `${startDateMonth} ${startDateYear} – ${endDateMonth} ${endDateYear}`;
};
var getMonthAndYearForSelectedDate = ($app) => {
  const dateMonth = toJSDate($app.datePickerState.selectedDate.value).toLocaleString(...getLocaleStringMonthArgs($app));
  const dateYear = toJSDate($app.datePickerState.selectedDate.value).toLocaleString(...getLocaleStringYearArgs($app));
  return `${dateMonth} ${dateYear}`;
};
function RangeHeading() {
  const $app = P(AppContext);
  const [currentHeading, setCurrentHeading] = p("");
  _(() => {
    if ($app.calendarState.view.value === InternalViewName.Week) {
      setCurrentHeading(getMonthAndYearForDateRange($app, $app.calendarState.range.value.start, $app.calendarState.range.value.end));
    }
    if ($app.calendarState.view.value === InternalViewName.MonthGrid || $app.calendarState.view.value === InternalViewName.Day || $app.calendarState.view.value === InternalViewName.MonthAgenda) {
      setCurrentHeading(getMonthAndYearForSelectedDate($app));
    }
  }, [$app.calendarState.range.value]);
  return u("span", { className: "sx__range-heading", children: currentHeading });
}
function TodayButton() {
  const $app = P(AppContext);
  const setToday = () => {
    $app.datePickerState.selectedDate.value = toDateString$1(/* @__PURE__ */ new Date());
  };
  return u("button", { className: "sx__today-button sx__ripple", onClick: setToday, children: $app.translate("Today") });
}
function ViewSelection() {
  const $app = P(AppContext);
  const [availableViews, setAvailableViews] = p([]);
  _(() => {
    if ($app.calendarState.isCalendarSmall.value) {
      setAvailableViews($app.config.views.filter((view) => view.hasSmallScreenCompat));
    } else {
      setAvailableViews($app.config.views.filter((view) => view.hasWideScreenCompat));
    }
  }, [$app.calendarState.isCalendarSmall.value]);
  const [selectedViewLabel, setSelectedViewLabel] = p("");
  _(() => {
    const selectedView = $app.config.views.find((view) => view.name === $app.calendarState.view.value);
    if (!selectedView)
      return;
    setSelectedViewLabel($app.translate(selectedView.label));
  }, [$app.calendarState.view.value]);
  const [isOpen, setIsOpen] = p(false);
  const clickOutsideListener = (event) => {
    const target = event.target;
    if (target instanceof HTMLElement && !target.closest(".sx__view-selection")) {
      setIsOpen(false);
    }
  };
  _(() => {
    document.addEventListener("click", clickOutsideListener);
    return () => document.removeEventListener("click", clickOutsideListener);
  }, []);
  const handleClickOnSelectionItem = (viewName) => {
    setIsOpen(false);
    $app.calendarState.view.value = viewName;
  };
  const [viewSelectionItems, setViewSelectionItems] = p();
  const [focusedViewIndex, setFocusedViewIndex] = p(0);
  const handleSelectedViewKeyDown = (keyboardEvent) => {
    if (isKeyEnterOrSpace(keyboardEvent)) {
      setIsOpen(!isOpen);
    }
    setTimeout(() => {
      var _a;
      const allOptions = (_a = $app.elements.calendarWrapper) === null || _a === void 0 ? void 0 : _a.querySelectorAll(".sx__view-selection-item");
      if (!allOptions)
        return;
      setViewSelectionItems(allOptions);
      const firstOption = allOptions[0];
      if (firstOption instanceof HTMLElement) {
        setFocusedViewIndex(0);
        firstOption.focus();
      }
    }, 50);
  };
  const navigateUpOrDown = (keyboardEvent, viewName) => {
    if (!viewSelectionItems)
      return;
    if (keyboardEvent.key === "ArrowDown") {
      const nextOption = viewSelectionItems[focusedViewIndex + 1];
      if (nextOption instanceof HTMLElement) {
        setFocusedViewIndex(focusedViewIndex + 1);
        nextOption.focus();
      }
    } else if (keyboardEvent.key === "ArrowUp") {
      const prevOption = viewSelectionItems[focusedViewIndex - 1];
      if (prevOption instanceof HTMLElement) {
        setFocusedViewIndex(focusedViewIndex - 1);
        prevOption.focus();
      }
    } else if (isKeyEnterOrSpace(keyboardEvent)) {
      handleClickOnSelectionItem(viewName);
    }
  };
  return u("div", { className: "sx__view-selection", children: [u("div", { tabIndex: 0, role: "button", "aria-label": $app.translate("Select View"), className: "sx__view-selection-selected-item sx__ripple", onClick: () => setIsOpen(!isOpen), onKeyDown: handleSelectedViewKeyDown, children: selectedViewLabel }), isOpen && u("ul", { "data-testid": "view-selection-items", className: "sx__view-selection-items", children: availableViews.map((view) => u("li", { "aria-label": $app.translate("Select View") + " " + $app.translate(view.label), tabIndex: -1, role: "button", onKeyDown: (keyboardEvent) => navigateUpOrDown(keyboardEvent, view.name), onClick: () => handleClickOnSelectionItem(view.name), className: "sx__view-selection-item" + (view.name === $app.calendarState.view.value ? " is-selected" : ""), children: $app.translate(view.label) })) })] });
}
function ForwardBackwardNavigation() {
  const $app = P(AppContext);
  const navigate = (direction) => {
    const currentView = $app.config.views.find((view) => view.name === $app.calendarState.view.value);
    if (!currentView)
      return;
    $app.datePickerState.selectedDate.value = currentView.backwardForwardFn($app.datePickerState.selectedDate.value, direction === "forwards" ? currentView.backwardForwardUnits : -currentView.backwardForwardUnits);
  };
  const [localizedRange, setLocalizedRange] = p("");
  _(() => {
    setLocalizedRange(`${getLocalizedDate($app.calendarState.range.value.start, $app.config.locale)} ${$app.translate("to")} ${getLocalizedDate($app.calendarState.range.value.end, $app.config.locale)}`);
  }, [$app.calendarState.range.value]);
  return u(g, { children: u("div", { className: "sx__forward-backward-navigation", "aria-label": localizedRange, "aria-live": "polite", children: [u(Chevron, { onClick: () => navigate("backwards"), direction: "previous", buttonText: $app.translate("Previous period") }), u(Chevron, { onClick: () => navigate("forwards"), direction: "next", buttonText: $app.translate("Next period") })] }) });
}
function CalendarHeader() {
  const $app = P(AppContext);
  const datePickerAppSingleton = new DatePickerAppSingletonBuilder().withDatePickerState($app.datePickerState).withConfig($app.datePickerConfig).withTranslate($app.translate).withTimeUnitsImpl($app.timeUnitsImpl).build();
  return u("header", { className: "sx__calendar-header", children: [u("div", { className: "sx__calendar-header-content", children: [u(TodayButton, {}), !$app.calendarState.isCalendarSmall.value && u(ForwardBackwardNavigation, {}), u(RangeHeading, {})] }), u("div", { className: "sx__calendar-header-content", children: [u(ViewSelection, {}), u(AppWrapper, { "$app": datePickerAppSingleton })] })] });
}
var setWrapperElement = ($app, calendarId) => {
  $app.elements.calendarWrapper = document.getElementById(calendarId);
};
var setScreenSizeCompatibleView = ($app, isSmall) => {
  const currentView = $app.config.views.find((view) => view.name === $app.calendarState.view.value);
  if (isSmall) {
    if (currentView.hasSmallScreenCompat)
      return;
    const smallScreenCompatibleView = $app.config.views.find((view) => view.hasSmallScreenCompat);
    if (smallScreenCompatibleView)
      $app.calendarState.view.value = smallScreenCompatibleView.name;
  } else {
    if (currentView.hasWideScreenCompat)
      return;
    const wideScreenCompatibleView = $app.config.views.find((view) => view.hasWideScreenCompat);
    if (wideScreenCompatibleView)
      $app.calendarState.view.value = wideScreenCompatibleView.name;
  }
};
var handleWindowResize = ($app) => {
  const documentRoot = document.documentElement;
  const calendarRoot = $app.elements.calendarWrapper;
  const documentFontSize = +window.getComputedStyle(documentRoot).fontSize.split("p")[0];
  const breakPointFor1RemEquals16px = 700;
  const multiplier = 16 / documentFontSize;
  const smallCalendarBreakpoint = breakPointFor1RemEquals16px / multiplier;
  if (!calendarRoot)
    return;
  const isSmall = calendarRoot.clientWidth < smallCalendarBreakpoint;
  const didIsSmallScreenChange = isSmall !== $app.calendarState.isCalendarSmall.value;
  if (!didIsSmallScreenChange)
    return;
  $app.calendarState.isCalendarSmall.value = isSmall;
  setScreenSizeCompatibleView($app, isSmall);
};
function useWrapperClasses($app) {
  const calendarWrapperClass = "sx__calendar-wrapper";
  const [wrapperClasses, setWrapperClasses] = p([
    calendarWrapperClass
  ]);
  _(() => {
    const classes = [calendarWrapperClass];
    if ($app.calendarState.isCalendarSmall.value)
      classes.push("sx__is-calendar-small");
    if ($app.calendarState.isDark.value)
      classes.push("is-dark");
    setWrapperClasses(classes);
  }, [
    $app.calendarState.isCalendarSmall.value,
    $app.calendarState.isDark.value
  ]);
  return wrapperClasses;
}
var initPlugins = ($app) => {
  Object.values($app.config.plugins).forEach((plugin) => {
    if (plugin === null || plugin === void 0 ? void 0 : plugin.init) {
      plugin.init($app);
    }
  });
};
var destroyPlugins = ($app) => {
  Object.values($app.config.plugins).forEach((plugin) => {
    if (plugin === null || plugin === void 0 ? void 0 : plugin.destroy)
      plugin.destroy();
  });
};
function CalendarWrapper({ $app }) {
  const calendarId = randomStringId();
  const viewContainerId = randomStringId();
  _(() => {
    setWrapperElement($app, calendarId);
    initPlugins($app);
    return () => destroyPlugins($app);
  }, []);
  const onResize = () => {
    handleWindowResize($app);
  };
  _(() => {
    onResize();
    window.addEventListener("resize", onResize);
    return () => window.removeEventListener("resize", onResize);
  }, []);
  const wrapperClasses = useWrapperClasses($app);
  const [currentView, setCurrentView] = p();
  const renderSelectedView = () => {
    const newView = $app.config.views.find((view) => view.name === $app.calendarState.view.value);
    const viewElement = document.getElementById(viewContainerId);
    if (!newView || !viewElement || newView.name === (currentView === null || currentView === void 0 ? void 0 : currentView.name))
      return;
    if (currentView)
      currentView.destroy();
    setCurrentView(newView);
    newView.render(viewElement, $app);
  };
  _(renderSelectedView, [$app.calendarState.view.value]);
  const [previousRangeStart, setPreviousRangeStart] = p("");
  const [transitionClass, setTransitionClass] = p("");
  _(() => {
    var _a, _b;
    const newRangeStartIsLaterThanPrevious = (((_a = $app.calendarState.range.value) === null || _a === void 0 ? void 0 : _a.start) || "") > previousRangeStart;
    setTransitionClass(newRangeStartIsLaterThanPrevious ? "sx__slide-left" : "sx__slide-right");
    setTimeout(() => {
      setTransitionClass("");
    }, 300);
    setPreviousRangeStart(((_b = $app.calendarState.range.value) === null || _b === void 0 ? void 0 : _b.start) || "");
  }, [$app.calendarState.range.value]);
  return u(g, { children: u("div", { className: wrapperClasses.join(" "), id: calendarId, children: u("div", { className: "sx__calendar", children: u(AppContext.Provider, { value: $app, children: [u(CalendarHeader, {}), u("div", { className: ["sx__view-container", transitionClass].join(" "), id: viewContainerId }), $app.config.plugins.eventModal && $app.config.plugins.eventModal.calendarEvent.value && u($app.config.plugins.eventModal.ComponentFn, { "$app": $app })] }) }) }) });
}
var timeStringRegex = /^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/;
var dateTimeStringRegex = /^(\d{4})-(\d{2})-(\d{2}) (0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/;
var dateStringRegex = /^(\d{4})-(\d{2})-(\d{2})$/;
var InvalidTimeStringError = class extends Error {
  constructor(timeString) {
    super(`Invalid time string: ${timeString}`);
  }
};
var minuteTimePointMultiplier = 1.6666666666666667;
var timePointsFromString = (timeString) => {
  if (!timeStringRegex.test(timeString))
    throw new InvalidTimeStringError(timeString);
  const [hoursInt, minutesInt] = timeString.split(":").map((time) => parseInt(time, 10));
  let minutePoints = (minutesInt * minuteTimePointMultiplier).toString();
  if (minutePoints.split(".")[0].length < 2)
    minutePoints = `0${minutePoints}`;
  return Number(hoursInt + minutePoints);
};
var timeStringFromTimePoints = (timePoints) => {
  const hours = Math.floor(timePoints / 100);
  const minutes = Math.round(timePoints % 100 / minuteTimePointMultiplier);
  return `${doubleDigit(hours)}:${doubleDigit(minutes)}`;
};
var addTimePointsToDateTime = (dateTimeString, pointsToAdd) => {
  const minutesToAdd = pointsToAdd / minuteTimePointMultiplier;
  const jsDate = toJSDate(dateTimeString);
  jsDate.setMinutes(jsDate.getMinutes() + minutesToAdd);
  return toDateTimeString(jsDate);
};
var WeekDay;
(function(WeekDay2) {
  WeekDay2[WeekDay2["SUNDAY"] = 0] = "SUNDAY";
  WeekDay2[WeekDay2["MONDAY"] = 1] = "MONDAY";
  WeekDay2[WeekDay2["TUESDAY"] = 2] = "TUESDAY";
  WeekDay2[WeekDay2["WEDNESDAY"] = 3] = "WEDNESDAY";
  WeekDay2[WeekDay2["THURSDAY"] = 4] = "THURSDAY";
  WeekDay2[WeekDay2["FRIDAY"] = 5] = "FRIDAY";
  WeekDay2[WeekDay2["SATURDAY"] = 6] = "SATURDAY";
})(WeekDay || (WeekDay = {}));
var DEFAULT_LOCALE = "en-US";
var DEFAULT_FIRST_DAY_OF_WEEK = WeekDay.MONDAY;
var DEFAULT_EVENT_COLOR_NAME = "primary";
var CalendarEventImpl = class {
  constructor(_config, id, start, end, title, people, location, description, calendarId, _foreignProperties = {}) {
    Object.defineProperty(this, "_config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _config
    });
    Object.defineProperty(this, "id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: id
    });
    Object.defineProperty(this, "start", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: start
    });
    Object.defineProperty(this, "end", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: end
    });
    Object.defineProperty(this, "title", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: title
    });
    Object.defineProperty(this, "people", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: people
    });
    Object.defineProperty(this, "location", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: location
    });
    Object.defineProperty(this, "description", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: description
    });
    Object.defineProperty(this, "calendarId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: calendarId
    });
    Object.defineProperty(this, "_foreignProperties", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _foreignProperties
    });
    Object.defineProperty(this, "_previousConcurrentEvents", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_totalConcurrentEvents", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_nDaysInGrid", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_eventFragments", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  get _isSingleDayTimed() {
    return dateTimeStringRegex.test(this.start) && dateTimeStringRegex.test(this.end) && dateFromDateTime(this.start) === dateFromDateTime(this.end);
  }
  get _isSingleDayFullDay() {
    return dateStringRegex.test(this.start) && dateStringRegex.test(this.end) && this.start === this.end;
  }
  get _isMultiDayTimed() {
    return dateTimeStringRegex.test(this.start) && dateTimeStringRegex.test(this.end) && dateFromDateTime(this.start) !== dateFromDateTime(this.end);
  }
  get _isMultiDayFullDay() {
    return dateStringRegex.test(this.start) && dateStringRegex.test(this.end) && this.start !== this.end;
  }
  get _isSingleHybridDayTimed() {
    if (!this._config.isHybridDay)
      return false;
    if (!dateTimeStringRegex.test(this.start) || !dateTimeStringRegex.test(this.end))
      return false;
    const startDate = dateFromDateTime(this.start);
    const endDate = dateFromDateTime(this.end);
    const endDateMinusOneDay = toDateString$1(new Date(toJSDate(endDate).getTime() - 864e5));
    if (startDate !== endDate && startDate !== endDateMinusOneDay)
      return false;
    const dayBoundaries = this._config.dayBoundaries;
    const eventStartTimePoints = timePointsFromString(timeFromDateTime(this.start));
    const eventEndTimePoints = timePointsFromString(timeFromDateTime(this.end));
    return eventStartTimePoints >= dayBoundaries.start && (eventEndTimePoints <= dayBoundaries.end || eventEndTimePoints > eventStartTimePoints) || eventStartTimePoints < dayBoundaries.end && eventEndTimePoints <= dayBoundaries.end;
  }
  get _color() {
    if (this.calendarId && this._config.calendars && this.calendarId in this._config.calendars) {
      return this._config.calendars[this.calendarId].colorName;
    }
    return DEFAULT_EVENT_COLOR_NAME;
  }
  _getForeignProperties() {
    return this._foreignProperties;
  }
  _getExternalEvent() {
    return {
      id: this.id,
      start: this.start,
      end: this.end,
      title: this.title,
      people: this.people,
      location: this.location,
      description: this.description,
      calendarId: this.calendarId,
      ...this._getForeignProperties()
    };
  }
};
var CalendarEventBuilder = class {
  constructor(_config, id, start, end) {
    Object.defineProperty(this, "_config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _config
    });
    Object.defineProperty(this, "id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: id
    });
    Object.defineProperty(this, "start", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: start
    });
    Object.defineProperty(this, "end", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: end
    });
    Object.defineProperty(this, "people", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "location", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "description", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "title", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "calendarId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_foreignProperties", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  build() {
    return new CalendarEventImpl(this._config, this.id, this.start, this.end, this.title, this.people, this.location, this.description, this.calendarId, this._foreignProperties);
  }
  withTitle(title) {
    this.title = title;
    return this;
  }
  withPeople(people) {
    this.people = people;
    return this;
  }
  withLocation(location) {
    this.location = location;
    return this;
  }
  withDescription(description) {
    this.description = description;
    return this;
  }
  withForeignProperties(foreignProperties) {
    this._foreignProperties = foreignProperties;
    return this;
  }
  withCalendarId(calendarId) {
    this.calendarId = calendarId;
    return this;
  }
};
var externalEventToInternal = (event, config) => {
  const { id, start, end, title, description, location, people, ...foreignProperties } = event;
  return new CalendarEventBuilder(config, id, start, end).withTitle(title).withDescription(description).withLocation(location).withPeople(people).withCalendarId(event.calendarId).withForeignProperties(foreignProperties).build();
};
var EventsFacadeImpl = class {
  constructor($app) {
    Object.defineProperty(this, "$app", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: $app
    });
  }
  add(event) {
    const newEvent = externalEventToInternal(event, this.$app.config);
    const copiedEvents = [...this.$app.calendarEvents.list.value];
    copiedEvents.push(newEvent);
    this.$app.calendarEvents.list.value = copiedEvents;
  }
  get(id) {
    var _a;
    return (_a = this.$app.calendarEvents.list.value.find((event) => event.id === id)) === null || _a === void 0 ? void 0 : _a._getExternalEvent();
  }
  getAll() {
    return this.$app.calendarEvents.list.value.map((event) => event._getExternalEvent());
  }
  remove(id) {
    const index = this.$app.calendarEvents.list.value.findIndex((event) => event.id === id);
    const copiedEvents = [...this.$app.calendarEvents.list.value];
    copiedEvents.splice(index, 1);
    this.$app.calendarEvents.list.value = copiedEvents;
  }
  update(event) {
    const index = this.$app.calendarEvents.list.value.findIndex((e) => e.id === event.id);
    const copiedEvents = [...this.$app.calendarEvents.list.value];
    copiedEvents.splice(index, 1, externalEventToInternal(event, this.$app.config));
    this.$app.calendarEvents.list.value = copiedEvents;
  }
};
var CalendarApp = class {
  constructor($app) {
    Object.defineProperty(this, "$app", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: $app
    });
    Object.defineProperty(this, "events", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.events = new EventsFacadeImpl(this.$app);
  }
  render(el) {
    B(y(CalendarWrapper, { $app: this.$app }), el);
  }
  setTheme(theme) {
    this.$app.calendarState.isDark.value = theme === "dark";
  }
  /**
   * @internal
   * Purpose: To be consumed by framework adapters for custom component rendering.
   * */
  _setCustomComponentFn(fnId, fn) {
    this.$app.config._customComponentFns[fnId] = fn;
  }
};
var CalendarAppSingletonImpl = class {
  constructor(config, timeUnitsImpl, calendarState, datePickerState, translate2, datePickerConfig, calendarEvents, elements = { calendarWrapper: void 0 }) {
    Object.defineProperty(this, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: config
    });
    Object.defineProperty(this, "timeUnitsImpl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: timeUnitsImpl
    });
    Object.defineProperty(this, "calendarState", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: calendarState
    });
    Object.defineProperty(this, "datePickerState", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: datePickerState
    });
    Object.defineProperty(this, "translate", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: translate2
    });
    Object.defineProperty(this, "datePickerConfig", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: datePickerConfig
    });
    Object.defineProperty(this, "calendarEvents", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: calendarEvents
    });
    Object.defineProperty(this, "elements", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: elements
    });
  }
};
var CalendarAppSingletonBuilder = class {
  constructor() {
    Object.defineProperty(this, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "timeUnitsImpl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "datePickerState", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "calendarState", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "translate", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "datePickerConfig", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "calendarEvents", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  build() {
    return new CalendarAppSingletonImpl(this.config, this.timeUnitsImpl, this.calendarState, this.datePickerState, this.translate, this.datePickerConfig, this.calendarEvents);
  }
  withConfig(config) {
    this.config = config;
    return this;
  }
  withTimeUnitsImpl(timeUnitsImpl) {
    this.timeUnitsImpl = timeUnitsImpl;
    return this;
  }
  withDatePickerState(datePickerState) {
    this.datePickerState = datePickerState;
    return this;
  }
  withCalendarState(calendarState) {
    this.calendarState = calendarState;
    return this;
  }
  withTranslate(translate2) {
    this.translate = translate2;
    return this;
  }
  withDatePickerConfig(datePickerConfig) {
    this.datePickerConfig = datePickerConfig;
    return this;
  }
  withCalendarEvents(calendarEvents) {
    this.calendarEvents = calendarEvents;
    return this;
  }
};
var DateFormatDelimiter;
(function(DateFormatDelimiter2) {
  DateFormatDelimiter2["SLASH"] = "/";
  DateFormatDelimiter2["DASH"] = "-";
  DateFormatDelimiter2["PERIOD"] = ".";
})(DateFormatDelimiter || (DateFormatDelimiter = {}));
var DateFormatOrder;
(function(DateFormatOrder2) {
  DateFormatOrder2["DMY"] = "DMY";
  DateFormatOrder2["MDY"] = "MDY";
  DateFormatOrder2["YMD"] = "YMD";
})(DateFormatOrder || (DateFormatOrder = {}));
var formatRules = {
  slashMDY: {
    delimiter: DateFormatDelimiter.SLASH,
    order: DateFormatOrder.MDY
  },
  slashDMY: {
    delimiter: DateFormatDelimiter.SLASH,
    order: DateFormatOrder.DMY
  },
  slashYMD: {
    delimiter: DateFormatDelimiter.SLASH,
    order: DateFormatOrder.YMD
  },
  periodDMY: {
    delimiter: DateFormatDelimiter.PERIOD,
    order: DateFormatOrder.DMY
  },
  dashYMD: {
    delimiter: DateFormatDelimiter.DASH,
    order: DateFormatOrder.YMD
  }
};
var dateFormatLocalizedRules = /* @__PURE__ */ new Map([
  ["en-US", formatRules.slashMDY],
  ["en-GB", formatRules.slashDMY],
  ["zh-CN", formatRules.slashYMD],
  ["de-DE", formatRules.periodDMY],
  ["sv-SE", formatRules.dashYMD]
]);
var LocaleNotSupportedError = class extends Error {
  constructor(locale) {
    super(`Locale not supported: ${locale}`);
  }
};
var InvalidDateFormatError = class extends Error {
  constructor(dateFormat, locale) {
    super(`Invalid date format: ${dateFormat} for locale: ${locale}`);
  }
};
var _getMatchesOrThrow = (format, matcher, locale) => {
  const matches = format.match(matcher);
  if (!matches)
    throw new InvalidDateFormatError(format, locale);
  return matches;
};
var toDateString = (format, locale) => {
  const internationalFormat = /^\d{4}-\d{2}-\d{2}$/;
  if (internationalFormat.test(format))
    return format;
  const localeDateFormatRule = dateFormatLocalizedRules.get(locale);
  if (!localeDateFormatRule)
    throw new LocaleNotSupportedError(locale);
  const { order, delimiter } = localeDateFormatRule;
  const pattern224Slashed = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/;
  const pattern224Dotted = /^(\d{1,2})\.(\d{1,2})\.(\d{4})$/;
  const pattern442Slashed = /^(\d{4})\/(\d{1,2})\/(\d{1,2})$/;
  if (order === DateFormatOrder.DMY && delimiter === DateFormatDelimiter.SLASH) {
    const matches = _getMatchesOrThrow(format, pattern224Slashed, locale);
    const [, day, month, year] = matches;
    return `${year}-${doubleDigit(+month)}-${doubleDigit(+day)}`;
  }
  if (order === DateFormatOrder.MDY && delimiter === DateFormatDelimiter.SLASH) {
    const matches = _getMatchesOrThrow(format, pattern224Slashed, locale);
    const [, month, day, year] = matches;
    return `${year}-${doubleDigit(+month)}-${doubleDigit(+day)}`;
  }
  if (order === DateFormatOrder.YMD && delimiter === DateFormatDelimiter.SLASH) {
    const matches = _getMatchesOrThrow(format, pattern442Slashed, locale);
    const [, year, month, day] = matches;
    return `${year}-${doubleDigit(+month)}-${doubleDigit(+day)}`;
  }
  if (order === DateFormatOrder.DMY && delimiter === DateFormatDelimiter.PERIOD) {
    const matches = _getMatchesOrThrow(format, pattern224Dotted, locale);
    const [, day, month, year] = matches;
    return `${year}-${doubleDigit(+month)}-${doubleDigit(+day)}`;
  }
  throw new InvalidDateFormatError(format, locale);
};
var createDatePickerState = (config, selectedDateParam) => {
  const currentDayDateString = toDateString$1(/* @__PURE__ */ new Date());
  const initialSelectedDate = typeof selectedDateParam === "string" ? selectedDateParam : currentDayDateString;
  const isOpen = a(false);
  const datePickerView = a(DatePickerView.MONTH_DAYS);
  const selectedDate = a(initialSelectedDate);
  const datePickerDate = a(initialSelectedDate || currentDayDateString);
  const inputDisplayedValue = a(selectedDateParam || "");
  O(() => {
    try {
      const newValue = toDateString(inputDisplayedValue.value, config.locale);
      selectedDate.value = newValue;
      datePickerDate.value = newValue;
    } catch (e) {
    }
  });
  O(() => {
    var _a;
    if ((_a = config.listeners) === null || _a === void 0 ? void 0 : _a.onChange)
      config.listeners.onChange(selectedDate.value);
  });
  return {
    isOpen,
    datePickerView,
    selectedDate,
    datePickerDate,
    inputDisplayedValue,
    open: () => isOpen.value = true,
    close: () => isOpen.value = false,
    toggle: () => isOpen.value = !isOpen.value,
    setView: (view) => datePickerView.value = view
  };
};
var datePickerDeDE = {
  Date: "Datum",
  "MM/DD/YYYY": "TT.MM.JJJJ",
  "Next month": "Nächster Monat",
  "Previous month": "Vorheriger Monat",
  "Choose Date": "Datum auswählen",
  "Select View": "Ansicht auswählen"
};
var calendarDeDE = {
  Today: "Heute",
  Month: "Monat",
  Week: "Woche",
  Day: "Tag",
  events: "Ereignisse",
  event: "Ereignis",
  "No events": "Keine Ereignisse",
  "Next period": "Nächster Zeitraum",
  "Previous period": "Vorheriger Zeitraum",
  to: "bis",
  // as in 2/1/2020 to 2/2/2020
  "Full day- and multiple day events": "Ganztägige und mehrtägige Ereignisse"
};
var deDE = {
  ...datePickerDeDE,
  ...calendarDeDE
};
var datePickerEnUS = {
  Date: "Date",
  "MM/DD/YYYY": "MM/DD/YYYY",
  "Next month": "Next month",
  "Previous month": "Previous month",
  "Choose Date": "Choose Date",
  "Select View": "Select View"
};
var calendarEnUS = {
  Today: "Today",
  Month: "Month",
  Week: "Week",
  Day: "Day",
  events: "events",
  event: "event",
  "No events": "No events",
  "Next period": "Next period",
  "Previous period": "Previous period",
  to: "to",
  // as in 2/1/2020 to 2/2/2020
  "Full day- and multiple day events": "Full day- and multiple day events"
};
var enUS = {
  ...datePickerEnUS,
  ...calendarEnUS
};
var datePickerItIT = {
  Date: "Data",
  "MM/DD/YYYY": "DD/MM/YYYY",
  "Next month": "Mese successivo",
  "Previous month": "Mese precedente",
  "Choose Date": "Scegli la data",
  "Select View": "Seleziona la vista"
};
var calendarItIT = {
  Today: "Oggi",
  Month: "Mese",
  Week: "Settimana",
  Day: "Giorno",
  events: "eventi",
  event: "evento",
  "No events": "Nessun evento",
  "Next period": "Periodo successivo",
  "Previous period": "Periodo precedente",
  to: "a",
  // as in 2/1/2020 to 2/2/2020
  "Full day- and multiple day events": "Eventi della giornata e plurigiornalieri"
};
var itIT = {
  ...datePickerItIT,
  ...calendarItIT
};
var datePickerEnGB = {
  Date: "Date",
  "MM/DD/YYYY": "DD/MM/YYYY",
  "Next month": "Next month",
  "Previous month": "Previous month",
  "Choose Date": "Choose Date",
  "Select View": "Select View"
};
var calendarEnGB = {
  Today: "Today",
  Month: "Month",
  Week: "Week",
  Day: "Day",
  events: "events",
  event: "event",
  "No events": "No events",
  "Next period": "Next period",
  "Previous period": "Previous period",
  to: "to",
  // as in 2/1/2020 to 2/2/2020
  "Full day- and multiple day events": "Full day- and multiple day events"
};
var enGB = {
  ...datePickerEnGB,
  ...calendarEnGB
};
var datePickerSvSE = {
  Date: "Datum",
  "MM/DD/YYYY": "ÅÅÅÅ-MM-DD",
  "Next month": "Nästa månad",
  "Previous month": "Föregående månad",
  "Choose Date": "Välj datum",
  "Select View": "Välj vy"
};
var calendarSvSE = {
  Today: "Idag",
  Month: "Månad",
  Week: "Vecka",
  Day: "Dag",
  events: "händelser",
  event: "händelse",
  "No events": "Inga händelser",
  "Next period": "Nästa period",
  "Previous period": "Föregående period",
  to: "till",
  // as in 2/1/2020 to 2/2/2020
  "Full day- and multiple day events": "Heldags- och flerdagshändelser"
};
var svSE = {
  ...datePickerSvSE,
  ...calendarSvSE
};
var datePickerZhCN = {
  Date: "日期",
  "MM/DD/YYYY": "年/月/日",
  "Next month": "下个月",
  "Previous month": "上个月",
  "Choose Date": "选择日期",
  "Select View": "选择视图"
};
var calendarZhCN = {
  Today: "今天",
  Month: "月",
  Week: "周",
  Day: "日",
  events: "场活动",
  event: "活动",
  "No events": "没有活动",
  "Next period": "下一段时间",
  "Previous period": "上一段时间",
  to: "至",
  // as in 2/1/2020 to 2/2/2020
  "Full day- and multiple day events": "全天和多天活动"
};
var zhCN = {
  ...datePickerZhCN,
  ...calendarZhCN
};
var datePickerJaJP = {
  Date: "日付",
  "MM/DD/YYYY": "年/月/日",
  "Next month": "次の月",
  "Previous month": "前の月",
  "Choose Date": "日付を選択",
  "Select View": "ビューを選択"
};
var calendarJaJP = {
  Today: "今日",
  Month: "月",
  Week: "週",
  Day: "日",
  events: "イベント",
  event: "イベント",
  "No events": "イベントなし",
  "Next period": "次の期間",
  "Previous period": "前の期間",
  to: "から",
  // as in 2/1/2020 to 2/2/2020
  "Full day- and multiple day events": "終日および複数日イベント"
};
var jaJP = {
  ...datePickerJaJP,
  ...calendarJaJP
};
var datePickerRuRU = {
  Date: "Дата",
  "MM/DD/YYYY": "ММ/ДД/ГГГГ",
  "Next month": "Следующий месяц",
  "Previous month": "Прошлый месяц",
  "Choose Date": "Выберите дату",
  "Select View": "Выберите вид"
};
var calendarRuRU = {
  Today: "Сегодня",
  Month: "Месяц",
  Week: "Неделя",
  Day: "День",
  events: "события",
  event: "событие",
  "No events": "Нет событий",
  "Next period": "Следующий период",
  "Previous period": "Прошлый период",
  to: "по",
  // as in 2/1/2020 to 2/2/2020
  "Full day- and multiple day events": "События на целый день и несколько дней подряд"
};
var ruRU = {
  ...datePickerRuRU,
  ...calendarRuRU
};
var datePickerKoKR = {
  Date: "일자",
  "MM/DD/YYYY": "년/월/일",
  "Next month": "다음 달",
  "Previous month": "이전 달",
  "Choose Date": "날짜 선택",
  "Select View": "보기 선택"
};
var calendarKoKR = {
  Today: "오늘",
  Month: "월",
  Week: "주",
  Day: "일",
  events: "일정들",
  event: "일정",
  "No events": "일정 없음",
  "Next period": "다음",
  "Previous period": "이전",
  to: "부터",
  // as in 2/1/2020 to 2/2/2020
  "Full day- and multiple day events": "종일 및 복수일 일정"
};
var koKR = {
  ...datePickerKoKR,
  ...calendarKoKR
};
var datePickerFrFR = {
  Date: "Date",
  "MM/DD/YYYY": "JJ/MM/AAAA",
  "Next month": "Mois suivant",
  "Previous month": "Mois précédent",
  "Choose Date": "Choisir une date",
  "Select View": "Choisir la vue"
};
var calendarFrFR = {
  Today: "Aujourd'hui",
  Month: "Mois",
  Week: "Semaine",
  Day: "Jour",
  events: "événements",
  event: "événement",
  "No events": "Aucun événement",
  "Next period": "Période suivante",
  "Previous period": "Période précédente",
  to: "à",
  // as in 2/1/2020 to 2/2/2020
  "Full day- and multiple day events": "Événements d'une ou plusieurs journées"
};
var frFR = {
  ...datePickerFrFR,
  ...calendarFrFR
};
var datePickerDaDK = {
  Date: "Dato",
  "MM/DD/YYYY": "ÅÅÅÅ-MM-DD",
  "Next month": "Næste måned",
  "Previous month": "Foregående måned",
  "Choose Date": "Vælg dato",
  "Select View": "Vælg visning"
};
var calendarDaDK = {
  Today: "I dag",
  Month: "Måned",
  Week: "Uge",
  Day: "Dag",
  events: "begivenheder",
  event: "begivenhed",
  "No events": "Ingen begivenheder",
  "Next period": "Næste periode",
  "Previous period": "Forgående periode",
  to: "til",
  // as in 2/1/2020 to 2/2/2020
  "Full day- and multiple day events": "Heldagsbegivenheder og flerdagsbegivenheder"
};
var daDK = {
  ...datePickerDaDK,
  ...calendarDaDK
};
var datePickerPlPL = {
  Date: "Data",
  "MM/DD/YYYY": "DD/MM/YYYY",
  "Next month": "Następny miesiąc",
  "Previous month": "Poprzedni miesiąc",
  "Choose Date": "Wybiewrz datę",
  "Select View": "Wybierz widok"
};
var calendarPlPL = {
  Today: "Dzisiaj",
  Month: "Miesiąc",
  Week: "Tydzień",
  Day: "Dzień",
  events: "wydarzenia",
  event: "wydarzenie",
  "No events": "Brak wydarzeń",
  "Next period": "Następny okres",
  "Previous period": "Poprzedni okres",
  to: "do",
  // as in 2/1/2020 to 2/2/2020
  "Full day- and multiple day events": "Wydarzenia całodniowe i wielodniowe"
};
var plPL = {
  ...datePickerPlPL,
  ...calendarPlPL
};
var datePickerEsES = {
  Date: "Fecha",
  "MM/DD/YYYY": "DD/MM/YYYY",
  "Next month": "Siguiente mes",
  "Previous month": "Mes anterior",
  "Choose Date": "Seleccione una fecha",
  "Select View": "Seleccione una vista"
};
var calendarEsES = {
  Today: "Hoy",
  Month: "Mes",
  Week: "Semana",
  Day: "Día",
  events: "eventos",
  event: "evento",
  "No events": "Sin eventos",
  "Next period": "Siguiente período",
  "Previous period": "Período anterior",
  to: "a",
  // as in 2/1/2020 to 2/2/2020
  "Full day- and multiple day events": "Día completo y eventos de múltiples días"
};
var esES = {
  ...datePickerEsES,
  ...calendarEsES
};
var InvalidLocaleError = class extends Error {
  constructor(locale) {
    super(`Invalid locale: ${locale}`);
  }
};
var translate = (locale, languages) => (key) => {
  if (!/^[a-z]{2}-[A-Z]{2}$/.test(locale))
    throw new InvalidLocaleError(locale);
  const deHyphenatedLocale = locale.replace("-", "");
  const language = languages[deHyphenatedLocale];
  if (!language)
    return key;
  return language[key] || key;
};
var translations = {
  deDE,
  enUS,
  itIT,
  enGB,
  svSE,
  zhCN,
  jaJP,
  ruRU,
  koKR,
  frFR,
  daDK,
  plPL,
  esES
};
var EventColors = class {
  constructor(config) {
    Object.defineProperty(this, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: config
    });
  }
  setLight() {
    Object.entries(this.config.calendars || {}).forEach(([calendarName, calendar]) => {
      if (!calendar.lightColors) {
        console.warn(`No light colors defined for calendar ${calendarName}`);
        return;
      }
      this.setColors(calendar.colorName, calendar.lightColors);
    });
  }
  setDark() {
    Object.entries(this.config.calendars || {}).forEach(([calendarName, calendar]) => {
      if (!calendar.darkColors) {
        console.warn(`No dark colors defined for calendar ${calendarName}`);
        return;
      }
      this.setColors(calendar.colorName, calendar.darkColors);
    });
  }
  setColors(colorName, colorDefinition) {
    document.documentElement.style.setProperty(`--sx-color-${colorName}`, colorDefinition.main);
    document.documentElement.style.setProperty(`--sx-color-${colorName}-container`, colorDefinition.container);
    document.documentElement.style.setProperty(`--sx-color-on-${colorName}-container`, colorDefinition.onContainer);
  }
};
var createCalendarState = (calendarConfig, timeUnitsImpl) => {
  var _a;
  const view = a(((_a = calendarConfig.views.find((view2) => view2.name === calendarConfig.defaultView)) === null || _a === void 0 ? void 0 : _a.name) || calendarConfig.views[0].name);
  const range = a(null);
  let wasInitialized = false;
  const callOnRangeUpdate = (_range) => {
    if (!wasInitialized)
      return wasInitialized = true;
    if (calendarConfig.callbacks.onRangeUpdate && _range.value) {
      calendarConfig.callbacks.onRangeUpdate(_range.value);
    }
  };
  O(() => {
    if (calendarConfig.callbacks.onRangeUpdate && range.value) {
      callOnRangeUpdate(range);
    }
  });
  const handleDateSelection = (date) => {
    const selectedView = calendarConfig.views.find((availableView) => availableView.name === view.value);
    selectedView.setDateRange({
      calendarConfig,
      date,
      range,
      timeUnitsImpl
    });
  };
  const isCalendarSmall = a(void 0);
  const isDark = a(calendarConfig.isDark || false);
  O(() => {
    const eventColors = new EventColors(calendarConfig);
    if (isDark.value) {
      eventColors.setDark();
    } else {
      eventColors.setLight();
    }
  });
  return {
    isDark,
    view,
    handleDateSelection,
    range,
    isCalendarSmall
  };
};
var createCalendarEventsImpl = (events, config) => {
  const list = a(events.map((event) => {
    return externalEventToInternal(event, config);
  }));
  return {
    list
  };
};
InternalViewName.Week;
var DEFAULT_DAY_BOUNDARIES = {
  start: 0,
  end: 2400
};
var DEFAULT_WEEK_GRID_HEIGHT = 1600;
var DATE_GRID_BLOCKER = "blocker";
var timePointsPerDay = (dayStart, dayEnd, isHybridDay) => {
  if (dayStart === dayEnd)
    return 2400;
  if (isHybridDay)
    return 2400 - dayStart + dayEnd;
  return dayEnd - dayStart;
};
var CalendarConfigImpl = class {
  constructor(locale = DEFAULT_LOCALE, firstDayOfWeek = DEFAULT_FIRST_DAY_OF_WEEK, defaultView = InternalViewName.Week, views = [], dayBoundaries = DEFAULT_DAY_BOUNDARIES, weekOptions = {
    gridHeight: DEFAULT_WEEK_GRID_HEIGHT
  }, calendars = {}, plugins = {}, isDark = false, callbacks = {}, _customComponentFns = {}) {
    Object.defineProperty(this, "locale", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: locale
    });
    Object.defineProperty(this, "firstDayOfWeek", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: firstDayOfWeek
    });
    Object.defineProperty(this, "defaultView", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: defaultView
    });
    Object.defineProperty(this, "views", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: views
    });
    Object.defineProperty(this, "dayBoundaries", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: dayBoundaries
    });
    Object.defineProperty(this, "weekOptions", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: weekOptions
    });
    Object.defineProperty(this, "calendars", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: calendars
    });
    Object.defineProperty(this, "plugins", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: plugins
    });
    Object.defineProperty(this, "isDark", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: isDark
    });
    Object.defineProperty(this, "callbacks", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: callbacks
    });
    Object.defineProperty(this, "_customComponentFns", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _customComponentFns
    });
  }
  get isHybridDay() {
    return this.dayBoundaries.start > this.dayBoundaries.end || this.dayBoundaries.start !== 0 && this.dayBoundaries.start === this.dayBoundaries.end;
  }
  get timePointsPerDay() {
    return timePointsPerDay(this.dayBoundaries.start, this.dayBoundaries.end, this.isHybridDay);
  }
};
var CalendarConfigBuilder = class {
  constructor() {
    Object.defineProperty(this, "locale", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "firstDayOfWeek", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "defaultView", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "views", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "dayBoundaries", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "weekOptions", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "calendars", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "plugins", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "isDark", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "callbacks", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  build() {
    return new CalendarConfigImpl(this.locale, this.firstDayOfWeek, this.defaultView, this.views, this.dayBoundaries, this.weekOptions, this.calendars, this.plugins, this.isDark, this.callbacks, {});
  }
  withLocale(locale) {
    this.locale = locale;
    return this;
  }
  withFirstDayOfWeek(firstDayOfWeek) {
    this.firstDayOfWeek = firstDayOfWeek;
    return this;
  }
  withDefaultView(defaultView) {
    this.defaultView = defaultView;
    return this;
  }
  withViews(views) {
    this.views = views;
    return this;
  }
  withDayBoundaries(dayBoundaries) {
    if (!dayBoundaries)
      return this;
    this.dayBoundaries = {
      start: timePointsFromString(dayBoundaries.start),
      end: timePointsFromString(dayBoundaries.end)
    };
    return this;
  }
  withWeekOptions(weekOptions) {
    this.weekOptions = weekOptions;
    return this;
  }
  withCalendars(calendars) {
    this.calendars = calendars;
    return this;
  }
  withPlugins(plugins) {
    if (!plugins)
      return this;
    plugins.forEach((plugin) => {
      this.plugins[plugin.name] = plugin;
    });
    return this;
  }
  withIsDark(isDark) {
    this.isDark = isDark;
    return this;
  }
  withCallbacks(listeners) {
    this.callbacks = listeners;
    return this;
  }
};
var createInternalConfig = (config) => {
  return new CalendarConfigBuilder().withLocale(config.locale).withFirstDayOfWeek(config.firstDayOfWeek).withDefaultView(config.defaultView).withViews(config.views).withDayBoundaries(config.dayBoundaries).withWeekOptions(config.weekOptions).withCalendars(config.calendars).withPlugins(config.plugins).withIsDark(config.isDark).withCallbacks(config.callbacks).build();
};
var Month;
(function(Month2) {
  Month2[Month2["JANUARY"] = 0] = "JANUARY";
  Month2[Month2["FEBRUARY"] = 1] = "FEBRUARY";
  Month2[Month2["MARCH"] = 2] = "MARCH";
  Month2[Month2["APRIL"] = 3] = "APRIL";
  Month2[Month2["MAY"] = 4] = "MAY";
  Month2[Month2["JUNE"] = 5] = "JUNE";
  Month2[Month2["JULY"] = 6] = "JULY";
  Month2[Month2["AUGUST"] = 7] = "AUGUST";
  Month2[Month2["SEPTEMBER"] = 8] = "SEPTEMBER";
  Month2[Month2["OCTOBER"] = 9] = "OCTOBER";
  Month2[Month2["NOVEMBER"] = 10] = "NOVEMBER";
  Month2[Month2["DECEMBER"] = 11] = "DECEMBER";
})(Month || (Month = {}));
var NoYearZeroError = class extends Error {
  constructor() {
    super("Year zero does not exist in the Gregorian calendar.");
  }
};
var ExtendedDateImpl = class extends Date {
  constructor(yearArg, monthArg, dateArg) {
    super(yearArg, monthArg, dateArg);
    if (yearArg === 0)
      throw new NoYearZeroError();
    this.setFullYear(yearArg);
  }
  get year() {
    return this.getFullYear();
  }
  get month() {
    return this.getMonth();
  }
  get date() {
    return this.getDate();
  }
};
var TimeUnitsImpl = class {
  constructor(firstDayOfWeek = DEFAULT_FIRST_DAY_OF_WEEK) {
    Object.defineProperty(this, "firstDayOfWeek", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: firstDayOfWeek
    });
  }
  getMonthWithTrailingAndLeadingDays(year, month) {
    if (year === 0)
      throw new NoYearZeroError();
    const firstDateOfMonth = new Date(year, month, 1);
    const monthWithDates = [this.getWeekFor(firstDateOfMonth)];
    let isInMonth = true;
    let first = monthWithDates[0][0];
    while (isInMonth) {
      const newFirstDayOfWeek = new Date(first.getFullYear(), first.getMonth(), first.getDate() + 7);
      if (newFirstDayOfWeek.getMonth() === month) {
        monthWithDates.push(this.getWeekFor(newFirstDayOfWeek));
        first = newFirstDayOfWeek;
      } else {
        isInMonth = false;
      }
    }
    return monthWithDates;
  }
  getWeekFor(date) {
    const week = [this.getFirstDateOfWeek(date)];
    while (week.length < 7) {
      const lastDateOfWeek = week[week.length - 1];
      const nextDateOfWeek = new Date(lastDateOfWeek);
      nextDateOfWeek.setDate(lastDateOfWeek.getDate() + 1);
      week.push(nextDateOfWeek);
    }
    return week;
  }
  getMonthsFor(year) {
    return Object.values(Month).filter((month) => !isNaN(Number(month))).map((month) => new ExtendedDateImpl(year, Number(month), 1));
  }
  getFirstDateOfWeek(date) {
    const dateIsNthDayOfWeek = date.getDay() - this.firstDayOfWeek;
    const firstDateOfWeek = date;
    if (dateIsNthDayOfWeek === 0) {
      return firstDateOfWeek;
    } else if (dateIsNthDayOfWeek > 0) {
      firstDateOfWeek.setDate(date.getDate() - dateIsNthDayOfWeek);
    } else {
      firstDateOfWeek.setDate(date.getDate() - (7 + dateIsNthDayOfWeek));
    }
    return firstDateOfWeek;
  }
};
var TimeUnitsBuilder = class {
  constructor() {
    Object.defineProperty(this, "firstDayOfWeek", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  build() {
    return new TimeUnitsImpl(this.firstDayOfWeek);
  }
  withFirstDayOfWeek(firstDayOfWeek) {
    this.firstDayOfWeek = firstDayOfWeek;
    return this;
  }
};
var createTimeUnitsImpl = (internalConfig) => {
  return new TimeUnitsBuilder().withFirstDayOfWeek(internalConfig.firstDayOfWeek).build();
};
var Placement;
(function(Placement2) {
  Placement2["TOP_START"] = "top-start";
  Placement2["TOP_END"] = "top-end";
  Placement2["BOTTOM_START"] = "bottom-start";
  Placement2["BOTTOM_END"] = "bottom-end";
})(Placement || (Placement = {}));
var ConfigImpl = class {
  constructor(locale = DEFAULT_LOCALE, firstDayOfWeek = DEFAULT_FIRST_DAY_OF_WEEK, min = toDateString$1(new Date(1970, 0, 1)), max = toDateString$1(new Date((/* @__PURE__ */ new Date()).getFullYear() + 1, 11, 31)), placement = Placement.BOTTOM_START, listeners = {}, style = {}) {
    Object.defineProperty(this, "locale", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: locale
    });
    Object.defineProperty(this, "firstDayOfWeek", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: firstDayOfWeek
    });
    Object.defineProperty(this, "min", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: min
    });
    Object.defineProperty(this, "max", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: max
    });
    Object.defineProperty(this, "placement", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: placement
    });
    Object.defineProperty(this, "listeners", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: listeners
    });
    Object.defineProperty(this, "style", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: style
    });
  }
};
var ConfigBuilder = class {
  constructor() {
    Object.defineProperty(this, "locale", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "firstDayOfWeek", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "min", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "max", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "placement", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "listeners", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "style", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  build() {
    return new ConfigImpl(this.locale, this.firstDayOfWeek, this.min, this.max, this.placement, this.listeners, this.style);
  }
  withLocale(locale) {
    this.locale = locale;
    return this;
  }
  withFirstDayOfWeek(firstDayOfWeek) {
    this.firstDayOfWeek = firstDayOfWeek;
    return this;
  }
  withMin(min) {
    this.min = min;
    return this;
  }
  withMax(max) {
    this.max = max;
    return this;
  }
  withPlacement(placement) {
    this.placement = placement;
    return this;
  }
  withListeners(listeners) {
    this.listeners = listeners;
    return this;
  }
  withStyle(style) {
    this.style = style;
    return this;
  }
};
var createDatePickerConfig = (config, dateSelectionCallback) => {
  var _a, _b, _c;
  return new ConfigBuilder().withLocale(config.locale).withFirstDayOfWeek(config.firstDayOfWeek).withMin((_a = config.datePicker) === null || _a === void 0 ? void 0 : _a.min).withMax((_b = config.datePicker) === null || _b === void 0 ? void 0 : _b.max).withStyle((_c = config.datePicker) === null || _c === void 0 ? void 0 : _c.style).withPlacement(Placement.BOTTOM_END).withListeners({ onChange: dateSelectionCallback }).build();
};
var createCalendarAppSingleton = (config) => {
  var _a;
  const internalConfig = createInternalConfig(config);
  const timeUnitsImpl = createTimeUnitsImpl(internalConfig);
  const calendarState = createCalendarState(internalConfig, timeUnitsImpl);
  const dateSelectionCallback = (date) => {
    calendarState.handleDateSelection(date);
  };
  const datePickerConfig = createDatePickerConfig(config, dateSelectionCallback);
  const datePickerState = createDatePickerState(datePickerConfig, config.selectedDate || ((_a = config.datePicker) === null || _a === void 0 ? void 0 : _a.selectedDate));
  const calendarEvents = createCalendarEventsImpl(config.events || [], internalConfig);
  return new CalendarAppSingletonBuilder().withConfig(internalConfig).withTimeUnitsImpl(timeUnitsImpl).withDatePickerState(datePickerState).withCalendarEvents(calendarEvents).withDatePickerConfig(datePickerConfig).withCalendarState(calendarState).withTranslate(translate(internalConfig.locale, translations)).build();
};
var createCalendar = (config) => {
  return new CalendarApp(createCalendarAppSingleton(config));
};
var PreactView = class {
  constructor(config) {
    Object.defineProperty(this, "randomId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: randomStringId()
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "label", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "Component", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "setDateRange", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "hasSmallScreenCompat", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "hasWideScreenCompat", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "backwardForwardFn", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "backwardForwardUnits", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = config.name;
    this.label = config.label;
    this.Component = config.Component;
    this.setDateRange = config.setDateRange;
    this.hasSmallScreenCompat = config.hasSmallScreenCompat;
    this.hasWideScreenCompat = config.hasWideScreenCompat;
    this.backwardForwardFn = config.backwardForwardFn;
    this.backwardForwardUnits = config.backwardForwardUnits;
  }
  render(onElement, $app) {
    B(y(this.Component, { $app, id: this.randomId }), onElement);
  }
  destroy() {
    const el = document.getElementById(this.randomId);
    if (el) {
      el.remove();
    }
  }
};
var createPreactView = (config) => {
  return new PreactView(config);
};
var timePointToPercentage = (timePointsInDay, dayBoundaries, timePoint) => {
  if (timePoint < dayBoundaries.start) {
    const firstDayTimePoints = 2400 - dayBoundaries.start;
    return (timePoint + firstDayTimePoints) / timePointsInDay * 100;
  }
  return (timePoint - dayBoundaries.start) / timePointsInDay * 100;
};
var getEventHeight = (start, end, dayBoundaries, pointsPerDay) => {
  return timePointToPercentage(pointsPerDay, dayBoundaries, timePointsFromString(timeFromDateTime(end))) - timePointToPercentage(pointsPerDay, dayBoundaries, timePointsFromString(timeFromDateTime(start)));
};
var getEventTop = (start, dayBoundaries, pointsPerDay) => {
  return timePointToPercentage(pointsPerDay, dayBoundaries, timePointsFromString(timeFromDateTime(start)));
};
var getLeftRule = (calendarEvent) => {
  if (!calendarEvent._totalConcurrentEvents || !calendarEvent._previousConcurrentEvents)
    return 0;
  return (calendarEvent._previousConcurrentEvents || 0) / (calendarEvent._totalConcurrentEvents || 0) * 100;
};
var getWidthRule = (leftRule) => {
  return 100 - leftRule;
};
var getBorderRule = (calendarEvent) => {
  if (!calendarEvent._previousConcurrentEvents)
    return 0;
  return "1px solid #fff";
};
function UserIcon({ strokeColor }) {
  return u(g, { children: u("svg", { className: "sx__event-icon", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [u("g", { id: "SVGRepo_bgCarrier", "stroke-width": "0" }), u("g", { id: "SVGRepo_tracerCarrier", "stroke-linecap": "round", "stroke-linejoin": "round" }), u("g", { id: "SVGRepo_iconCarrier", children: [u("path", { d: "M15 7C15 8.65685 13.6569 10 12 10C10.3431 10 9 8.65685 9 7C9 5.34315 10.3431 4 12 4C13.6569 4 15 5.34315 15 7Z", stroke: strokeColor, "stroke-width": "2" }), u("path", { d: "M5 19.5C5 15.9101 7.91015 13 11.5 13H12.5C16.0899 13 19 15.9101 19 19.5V20C19 20.5523 18.5523 21 18 21H6C5.44772 21 5 20.5523 5 20V19.5Z", stroke: strokeColor, "stroke-width": "2" })] })] }) });
}
function TimeIcon({ strokeColor }) {
  return u(g, { children: u("svg", { className: "sx__event-icon", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [u("g", { id: "SVGRepo_bgCarrier", "stroke-width": "0" }), u("g", { id: "SVGRepo_tracerCarrier", "stroke-linecap": "round", "stroke-linejoin": "round" }), u("g", { id: "SVGRepo_iconCarrier", children: [u("path", { d: "M12 8V12L15 15", stroke: strokeColor, "stroke-width": "2", "stroke-linecap": "round" }), u("circle", { cx: "12", cy: "12", r: "9", stroke: strokeColor, "stroke-width": "2" })] })] }) });
}
var deepCloneEvent = (calendarEvent, $app) => {
  const calendarEventInternal = new CalendarEventBuilder($app.config, calendarEvent.id, calendarEvent.start, calendarEvent.end).withTitle(calendarEvent.title).withPeople(calendarEvent.people).withCalendarId(calendarEvent.calendarId).withForeignProperties(JSON.parse(JSON.stringify(calendarEvent._getForeignProperties()))).withLocation(calendarEvent.location).withDescription(calendarEvent.description).build();
  calendarEventInternal._nDaysInGrid = calendarEvent._nDaysInGrid;
  return calendarEventInternal;
};
var getTimeGridEventCopyElementId = (id) => {
  return "time-grid-event-copy-" + id;
};
var isUIEventTouchEvent = (event) => {
  return "touches" in event && typeof event.touches === "object";
};
function useEventInteractions($app) {
  const [eventCopy, setEventCopy] = p();
  const updateCopy = (newCopy) => {
    if (!newCopy)
      return setEventCopy(void 0);
    setEventCopy(deepCloneEvent(newCopy, $app));
  };
  const [dragStartTimeout, setDragStartTimeout] = p();
  const createDragStartTimeout = (callback, uiEvent) => {
    setDragStartTimeout(setTimeout(() => callback(uiEvent), 150));
  };
  const setClickedEvent = (uiEvent, calendarEvent) => {
    if (isUIEventTouchEvent(uiEvent) && uiEvent.touches.length === 0)
      return;
    if (!$app.config.plugins.eventModal)
      return;
    const eventTarget = uiEvent.target;
    if (!(eventTarget instanceof HTMLElement))
      return;
    const calendarEventElement = eventTarget.classList.contains("sx__event") ? eventTarget : eventTarget.closest(".sx__event");
    if (calendarEventElement) {
      $app.config.plugins.eventModal.setCalendarEvent(calendarEvent, calendarEventElement.getBoundingClientRect());
    }
  };
  const setClickedEventIfNotDragging = (calendarEvent, uiEvent) => {
    if (dragStartTimeout) {
      clearTimeout(dragStartTimeout);
      setClickedEvent(uiEvent, calendarEvent);
    }
    setDragStartTimeout(void 0);
  };
  return {
    eventCopy,
    updateCopy,
    createDragStartTimeout,
    setClickedEventIfNotDragging,
    setClickedEvent
  };
}
var concatenatePeople = (people) => {
  return people.reduce((acc, person, index) => {
    if (index === 0)
      return person;
    if (index === people.length - 1)
      return `${acc} & ${person}`;
    return `${acc}, ${person}`;
  }, "");
};
var getCCID = (customComponent, calendarEvent, isCopy) => {
  let customComponentId = customComponent ? "custom-time-grid-event-" + calendarEvent.id : void 0;
  if (customComponentId && isCopy)
    customComponentId += "-copy";
  return customComponentId;
};
var getElementByCCID = (customComponentId) => document.querySelector(`[data-ccid="${customComponentId}"]`);
var invokeOnEventClickCallback = ($app, calendarEvent) => {
  if ($app.config.callbacks.onEventClick) {
    $app.config.callbacks.onEventClick(calendarEvent._getExternalEvent());
  }
};
var getEventCoordinates = (uiEvent) => {
  const actualEvent = isUIEventTouchEvent(uiEvent) ? uiEvent.touches[0] : uiEvent;
  return {
    clientX: actualEvent.clientX,
    clientY: actualEvent.clientY
  };
};
function TimeGridEvent({ calendarEvent, dayBoundariesDateTime, isCopy }) {
  const $app = P(AppContext);
  const { eventCopy, updateCopy, createDragStartTimeout, setClickedEventIfNotDragging } = useEventInteractions($app);
  const localizeArgs = [
    $app.config.locale,
    { hour: "numeric", minute: "numeric" }
  ];
  const getEventTime = (start, end) => {
    const localizedStartTime = toJSDate(start).toLocaleTimeString(...localizeArgs);
    const localizedEndTime = toJSDate(end).toLocaleTimeString(...localizeArgs);
    return `${localizedStartTime} – ${localizedEndTime}`;
  };
  const eventCSSVariables = {
    borderLeft: `4px solid var(--sx-color-${calendarEvent._color})`,
    textColor: `var(--sx-color-on-${calendarEvent._color}-container)`,
    backgroundColor: `var(--sx-color-${calendarEvent._color}-container)`,
    iconStroke: `var(--sx-color-on-${calendarEvent._color}-container)`
  };
  const leftRule = getLeftRule(calendarEvent);
  const handleStartDrag = (uiEvent) => {
    if (isUIEventTouchEvent(uiEvent))
      uiEvent.preventDefault();
    if (!dayBoundariesDateTime)
      return;
    if (!uiEvent.target)
      return;
    if (!$app.config.plugins.dragAndDrop)
      return;
    const newEventCopy = deepCloneEvent(calendarEvent, $app);
    updateCopy(newEventCopy);
    $app.config.plugins.dragAndDrop.createTimeGridDragHandler({
      $app,
      eventCoordinates: getEventCoordinates(uiEvent),
      updateCopy,
      eventCopy: newEventCopy
    }, dayBoundariesDateTime);
  };
  const customComponent = $app.config._customComponentFns.timeGridEvent;
  const customComponentId = getCCID(customComponent, calendarEvent, isCopy);
  _(() => {
    if (!customComponent)
      return;
    customComponent(getElementByCCID(customComponentId), {
      calendarEvent: calendarEvent._getExternalEvent()
    });
  }, []);
  const handleOnClick = (e) => {
    e.stopPropagation();
    invokeOnEventClickCallback($app, calendarEvent);
  };
  const startResize = (e) => {
    e.stopPropagation();
    if (!dayBoundariesDateTime)
      return;
    if ($app.config.plugins.resize) {
      $app.config.plugins.resize.createTimeGridEventResizer(calendarEvent, e, dayBoundariesDateTime);
    }
  };
  return u(g, { children: [u("div", { id: isCopy ? getTimeGridEventCopyElementId(calendarEvent.id) : void 0, onClick: handleOnClick, onMouseDown: (e) => createDragStartTimeout(handleStartDrag, e), onMouseUp: (e) => setClickedEventIfNotDragging(calendarEvent, e), onTouchStart: (e) => createDragStartTimeout(handleStartDrag, e), onTouchEnd: (e) => setClickedEventIfNotDragging(calendarEvent, e), className: "sx__time-grid-event sx__event" + (isCopy ? " is-event-copy" : ""), tabIndex: 0, style: {
    top: `${getEventTop(calendarEvent.start, $app.config.dayBoundaries, $app.config.timePointsPerDay)}%`,
    height: `${getEventHeight(calendarEvent.start, calendarEvent.end, $app.config.dayBoundaries, $app.config.timePointsPerDay)}%`,
    left: `${leftRule}%`,
    width: `${getWidthRule(leftRule)}%`,
    backgroundColor: customComponent ? void 0 : eventCSSVariables.backgroundColor,
    color: customComponent ? void 0 : eventCSSVariables.textColor,
    border: customComponent ? void 0 : getBorderRule(calendarEvent),
    borderLeft: customComponent ? void 0 : eventCSSVariables.borderLeft,
    padding: customComponent ? "0" : void 0
  }, children: u("div", { "data-ccid": customComponentId, className: "sx__time-grid-event-inner", children: [!customComponent && u(g, { children: [calendarEvent.title && u("div", { className: "sx__time-grid-event-title", children: calendarEvent.title }), u("div", { className: "sx__time-grid-event-time", children: [u(TimeIcon, { strokeColor: eventCSSVariables.iconStroke }), getEventTime(calendarEvent.start, calendarEvent.end)] }), calendarEvent.people && u("div", { className: "sx__time-grid-event-people", children: [u(UserIcon, { strokeColor: eventCSSVariables.iconStroke }), concatenatePeople(calendarEvent.people)] })] }), $app.config.plugins.resize && u("div", { className: "sx__time-grid-event-resize-handle", onMouseDown: startResize })] }) }), eventCopy && u(TimeGridEvent, { calendarEvent: eventCopy, isCopy: true })] });
}
var sortEventsByStartAndEnd = (a2, b) => {
  if (a2.start === b.start) {
    if (a2.end < b.end)
      return 1;
    if (a2.end > b.end)
      return -1;
    return 0;
  }
  if (a2.start < b.start)
    return -1;
  if (a2.start > b.start)
    return 1;
  return 0;
};
var handleEventConcurrency = (sortedEvents, concurrentEventsCache = [], currentIndex = 0) => {
  for (let i = currentIndex; i < sortedEvents.length; i++) {
    const event = sortedEvents[i];
    const nextEvent = sortedEvents[i + 1];
    if (concurrentEventsCache.length && (!nextEvent || concurrentEventsCache.every((e) => e.end < nextEvent.start))) {
      concurrentEventsCache.push(event);
      for (let ii = 0; ii < concurrentEventsCache.length; ii++) {
        const currentEvent = concurrentEventsCache[ii];
        const NpreviousConcurrentEvents = concurrentEventsCache.filter((cachedEvent, index) => {
          if (cachedEvent === currentEvent || index > ii)
            return false;
          return cachedEvent.start <= currentEvent.start && cachedEvent.end > currentEvent.start;
        }).length;
        const NupcomingConcurrentEvents = concurrentEventsCache.filter((cachedEvent, index) => {
          if (cachedEvent === currentEvent || index < ii)
            return false;
          return cachedEvent.start < currentEvent.end && cachedEvent.end >= currentEvent.start;
        }).length;
        currentEvent._totalConcurrentEvents = NpreviousConcurrentEvents + NupcomingConcurrentEvents + 1;
        currentEvent._previousConcurrentEvents = NpreviousConcurrentEvents;
      }
      concurrentEventsCache = [];
      return handleEventConcurrency(sortedEvents, concurrentEventsCache, i + 1);
    }
    if (nextEvent && event.end > nextEvent.start || concurrentEventsCache.some((e) => e.end > event.start)) {
      concurrentEventsCache.push(event);
      return handleEventConcurrency(sortedEvents, concurrentEventsCache, i + 1);
    }
  }
  return sortedEvents;
};
var getClickDateTime = (e, $app, dayStartDateTime) => {
  if (!(e.target instanceof HTMLElement))
    return;
  const DAY_GRID_CLASS_NAME = "sx__time-grid-day";
  const dayGridElement = e.target.classList.contains(DAY_GRID_CLASS_NAME) ? e.target : e.target.closest("." + DAY_GRID_CLASS_NAME);
  const clientY = e.clientY - dayGridElement.getBoundingClientRect().top;
  const clickPercentageOfDay = clientY / dayGridElement.getBoundingClientRect().height * 100;
  const clickTimePointsIntoDay = Math.round($app.config.timePointsPerDay / 100 * clickPercentageOfDay);
  return addTimePointsToDateTime(dayStartDateTime, clickTimePointsIntoDay);
};
function TimeGridDay({ calendarEvents, date }) {
  const $app = P(AppContext);
  const timeStringFromDayBoundary = timeStringFromTimePoints($app.config.dayBoundaries.start);
  const timeStringFromDayBoundaryEnd = timeStringFromTimePoints($app.config.dayBoundaries.end);
  const dayStartDateTime = setTimeInDateTimeString(date, timeStringFromDayBoundary);
  const dayEndDateTime = $app.config.isHybridDay ? addDays(setTimeInDateTimeString(date, timeStringFromDayBoundaryEnd), 1) : setTimeInDateTimeString(date, timeStringFromDayBoundaryEnd);
  const dayBoundariesDateTime = {
    start: dayStartDateTime,
    end: dayEndDateTime
  };
  const sortedEvents = calendarEvents.sort(sortEventsByStartAndEnd);
  const eventsWithConcurrency = handleEventConcurrency(sortedEvents);
  const handleOnClick = (e) => {
    if (!$app.config.callbacks.onClickDateTime)
      return;
    const clickDateTime = getClickDateTime(e, $app, dayStartDateTime);
    if (clickDateTime) {
      $app.config.callbacks.onClickDateTime(clickDateTime);
    }
  };
  return u("div", { className: "sx__time-grid-day", onClick: handleOnClick, "aria-label": getLocalizedDate(date, $app.config.locale), children: eventsWithConcurrency.map((event) => u(TimeGridEvent, { calendarEvent: event, dayBoundariesDateTime }, event.id)) });
}
var getTimeAxisHours = ({ start, end }, isHybridDay) => {
  const hours = [];
  let hour = Math.floor(start / 100);
  if (isHybridDay) {
    while (hour < 24) {
      hours.push(hour);
      hour += 1;
    }
    hour = 0;
  }
  const lastHour = end === 0 ? 24 : Math.ceil(end / 100);
  while (hour < lastHour) {
    hours.push(hour);
    hour += 1;
  }
  return hours;
};
function TimeAxis() {
  const $app = P(AppContext);
  const [hours, setHours] = p([]);
  _(() => {
    setHours(getTimeAxisHours($app.config.dayBoundaries, $app.config.isHybridDay));
    const hoursPerDay = $app.config.timePointsPerDay / 100;
    const pixelsPerHour = $app.config.weekOptions.gridHeight / hoursPerDay;
    document.documentElement.style.setProperty("--sx-week-grid-hour-height", `${pixelsPerHour}px`);
  }, []);
  return u(g, { children: u("div", { className: "sx__week-grid__time-axis", children: hours.map((hour) => u("div", { className: "sx__week-grid__hour", children: u("span", { className: "sx__week-grid__hour-text", children: new Date(0, 0, 0, hour).toLocaleTimeString($app.config.locale, {
    hour: "numeric"
  }) }) })) }) });
}
function DateAxis({ week }) {
  const $app = P(AppContext);
  const getClassNames = (date) => {
    const classNames = ["sx__week-grid__date"];
    if (isToday(date)) {
      classNames.push("sx__week-grid__date--is-today");
    }
    return classNames.join(" ");
  };
  return u(g, { children: u("div", { className: "sx__week-grid__date-axis", children: week.map((date) => u("div", { className: getClassNames(date), children: [u("div", { className: "sx__week-grid__day-name", children: getDayNameShort(date, $app.config.locale) }), u("div", { className: "sx__week-grid__date-number", children: date.getDate() })] })) }) });
}
var sortEventsForWeekView = (allCalendarEvents) => {
  const dateGridEvents = [];
  const timeGridEvents = [];
  for (const event of allCalendarEvents) {
    if (event._isSingleDayTimed || event._isSingleHybridDayTimed) {
      timeGridEvents.push(event);
      continue;
    }
    if (event._isSingleDayFullDay || event._isMultiDayFullDay || event._isMultiDayTimed) {
      dateGridEvents.push(event);
    }
  }
  return { timeGridEvents, dateGridEvents };
};
var createOneDay = (week, date) => {
  const dateString = toDateString$1(date);
  week[dateString] = {
    date: dateString,
    timeGridEvents: [],
    dateGridEvents: {}
  };
  return week;
};
var createWeek = ($app) => {
  if ($app.calendarState.view.value === InternalViewName.Day)
    return createOneDay({}, toJSDate($app.calendarState.range.value.start));
  return $app.timeUnitsImpl.getWeekFor(toJSDate($app.calendarState.range.value.start)).reduce(createOneDay, {});
};
var resetEventConcurrencyProperties = (event) => {
  event._previousConcurrentEvents = void 0;
  event._totalConcurrentEvents = void 0;
};
var positionInTimeGrid = (timeGridEvents, week, $app) => {
  for (const event of timeGridEvents) {
    resetEventConcurrencyProperties(event);
    const range = $app.calendarState.range.value;
    if (event.start >= range.start && event.end <= range.end) {
      let date = dateFromDateTime(event.start);
      const timeFromStart = timeFromDateTime(event.start);
      if (timePointsFromString(timeFromStart) < $app.config.dayBoundaries.start) {
        date = addDays(date, -1);
      }
      week[date].timeGridEvents.push(event);
    }
  }
  return week;
};
var positionInDateGrid = (sortedDateGridEvents, week) => {
  const weekDates = Object.keys(week).sort();
  const firstDateOfWeek = weekDates[0];
  const lastDateOfWeek = weekDates[weekDates.length - 1];
  const occupiedLevels = /* @__PURE__ */ new Set();
  for (const event of sortedDateGridEvents) {
    const eventOriginalStartDate = dateFromDateTime(event.start);
    const eventOriginalEndDate = dateFromDateTime(event.end);
    const isEventStartInWeek = !!week[eventOriginalStartDate];
    let isEventInWeek = isEventStartInWeek;
    if (!isEventStartInWeek && eventOriginalStartDate < firstDateOfWeek && eventOriginalEndDate >= firstDateOfWeek) {
      isEventInWeek = true;
    }
    if (!isEventInWeek)
      continue;
    const firstDateOfEvent = isEventStartInWeek ? eventOriginalStartDate : firstDateOfWeek;
    const lastDateOfEvent = eventOriginalEndDate <= lastDateOfWeek ? eventOriginalEndDate : lastDateOfWeek;
    const eventDays = Object.values(week).filter((day) => {
      return day.date >= firstDateOfEvent && day.date <= lastDateOfEvent;
    });
    let levelInWeekForEvent;
    let testLevel = 0;
    while (levelInWeekForEvent === void 0) {
      const isLevelFree = eventDays.every((day) => {
        return !day.dateGridEvents[testLevel];
      });
      if (isLevelFree) {
        levelInWeekForEvent = testLevel;
        occupiedLevels.add(testLevel);
      } else
        testLevel++;
    }
    for (const [eventDayIndex, eventDay] of eventDays.entries()) {
      if (eventDayIndex === 0) {
        event._nDaysInGrid = eventDays.length;
        eventDay.dateGridEvents[levelInWeekForEvent] = event;
      } else {
        eventDay.dateGridEvents[levelInWeekForEvent] = DATE_GRID_BLOCKER;
      }
    }
  }
  for (const level of Array.from(occupiedLevels)) {
    for (const [, day] of Object.entries(week)) {
      if (!day.dateGridEvents[level]) {
        day.dateGridEvents[level] = void 0;
      }
    }
  }
  return week;
};
var getWidthToSubtract = (hasOverflowLeft, hasOverflowRight, enableOverflowSubtraction) => {
  let widthToSubtract = 2;
  const eventOverflowMargin = 10;
  if (hasOverflowLeft && enableOverflowSubtraction)
    widthToSubtract += eventOverflowMargin;
  if (hasOverflowRight && enableOverflowSubtraction)
    widthToSubtract += eventOverflowMargin;
  return widthToSubtract;
};
var getBorderRadius = (hasOverflowLeft, hasOverflowRight, forceZeroRule) => {
  return {
    borderBottomLeftRadius: hasOverflowLeft || forceZeroRule ? 0 : void 0,
    borderTopLeftRadius: hasOverflowLeft || forceZeroRule ? 0 : void 0,
    borderBottomRightRadius: hasOverflowRight || forceZeroRule ? 0 : void 0,
    borderTopRightRadius: hasOverflowRight || forceZeroRule ? 0 : void 0
  };
};
function DateGridEvent({ calendarEvent, gridRow, isCopy }) {
  const $app = P(AppContext);
  const { eventCopy, updateCopy, setClickedEventIfNotDragging, createDragStartTimeout } = useEventInteractions($app);
  const eventCSSVariables = {
    borderLeft: `4px solid var(--sx-color-${calendarEvent._color})`,
    color: `var(--sx-color-on-${calendarEvent._color}-container)`,
    backgroundColor: `var(--sx-color-${calendarEvent._color}-container)`
  };
  const handleStartDrag = (uiEvent) => {
    if (!$app.config.plugins.dragAndDrop)
      return;
    if (isUIEventTouchEvent(uiEvent))
      uiEvent.preventDefault();
    const newEventCopy = deepCloneEvent(calendarEvent, $app);
    updateCopy(newEventCopy);
    $app.config.plugins.dragAndDrop.createDateGridDragHandler({
      eventCoordinates: getEventCoordinates(uiEvent),
      eventCopy: newEventCopy,
      updateCopy,
      $app
    });
  };
  const hasOverflowLeft = dateFromDateTime(calendarEvent.start) < dateFromDateTime($app.calendarState.range.value.start);
  const hasOverflowRight = dateFromDateTime(calendarEvent.end) > dateFromDateTime($app.calendarState.range.value.end);
  const overflowStyles = { backgroundColor: eventCSSVariables.backgroundColor };
  const customComponent = $app.config._customComponentFns.dateGridEvent;
  let customComponentId = customComponent ? "custom-date-grid-event-" + calendarEvent.id : void 0;
  if (isCopy && customComponentId)
    customComponentId += "-copy";
  _(() => {
    if (!customComponent)
      return;
    customComponent(getElementByCCID(customComponentId), {
      calendarEvent: calendarEvent._getExternalEvent()
    });
  }, []);
  const startResize = (mouseEvent) => {
    mouseEvent.stopPropagation();
    $app.config.plugins.resize.createDateGridEventResizer(calendarEvent, mouseEvent);
  };
  const eventClasses = [
    "sx__event",
    "sx__date-grid-event",
    "sx__date-grid-cell"
  ];
  if (isCopy)
    eventClasses.push(" sx__date-grid-event--copy");
  if (hasOverflowLeft)
    eventClasses.push(" sx__date-grid-event--overflow-left");
  if (hasOverflowRight)
    eventClasses.push(" sx__date-grid-event--overflow-right");
  const borderLeftNonCustom = hasOverflowLeft ? "none" : eventCSSVariables.borderLeft;
  return u(g, { children: [u("div", { id: isCopy ? getTimeGridEventCopyElementId(calendarEvent.id) : void 0, tabIndex: 0, "aria-label": calendarEvent.title + " " + getTimeStamp(calendarEvent, $app.config.locale, $app.translate("to")), "data-ccid": customComponentId, onMouseDown: (e) => createDragStartTimeout(handleStartDrag, e), onMouseUp: (e) => setClickedEventIfNotDragging(calendarEvent, e), onTouchStart: (e) => createDragStartTimeout(handleStartDrag, e), onTouchEnd: (e) => setClickedEventIfNotDragging(calendarEvent, e), onClick: () => invokeOnEventClickCallback($app, calendarEvent), className: eventClasses.join(" "), style: {
    width: `calc(${calendarEvent._nDaysInGrid * 100}% - ${getWidthToSubtract(hasOverflowLeft, hasOverflowRight, !customComponent)}px)`,
    gridRow,
    display: eventCopy ? "none" : "flex",
    padding: customComponent ? "0px" : void 0,
    borderLeft: customComponent ? void 0 : borderLeftNonCustom,
    color: customComponent ? void 0 : eventCSSVariables.color,
    backgroundColor: customComponent ? void 0 : eventCSSVariables.backgroundColor,
    ...getBorderRadius(hasOverflowLeft, hasOverflowRight, !!customComponent)
  }, children: [!customComponent && u(g, { children: [hasOverflowLeft && u("div", { className: "sx__date-grid-event--left-overflow", style: overflowStyles }), u("span", { className: "sx__date-grid-event-text", children: calendarEvent.title }), hasOverflowRight && u("div", { className: "sx__date-grid-event--right-overflow", style: overflowStyles })] }), $app.config.plugins.resize && !hasOverflowRight && u("div", { className: "sx__date-grid-event-resize-handle", onMouseDown: startResize })] }), eventCopy && u(DateGridEvent, { calendarEvent: eventCopy, gridRow, isCopy: true })] });
}
function DateGridDay({ calendarEvents }) {
  return u("div", { className: "sx__date-grid-day", children: Object.values(calendarEvents).map((event, index) => {
    if (event === DATE_GRID_BLOCKER || !event)
      return u("div", { className: "sx__date-grid-cell", style: { gridRow: index + 1 } });
    return u(DateGridEvent, { calendarEvent: event, gridRow: index + 1 });
  }) });
}
var WeekWrapper = ({ $app, id }) => {
  var _a, _b;
  document.documentElement.style.setProperty("--sx-week-grid-height", `${$app.config.weekOptions.gridHeight}px`);
  const [week, setWeek] = p({});
  const sortEventsIntoDateAndTimeGrids = () => {
    let newWeek = createWeek($app);
    const { dateGridEvents, timeGridEvents } = sortEventsForWeekView($app.calendarEvents.list.value);
    newWeek = positionInDateGrid(dateGridEvents.sort(sortEventsByStartAndEnd), newWeek);
    newWeek = positionInTimeGrid(timeGridEvents, newWeek, $app);
    setWeek(newWeek);
  };
  _(() => {
    var _a2, _b2;
    const rangeStart = (_a2 = $app.calendarState.range.value) === null || _a2 === void 0 ? void 0 : _a2.start;
    const rangeEnd = (_b2 = $app.calendarState.range.value) === null || _b2 === void 0 ? void 0 : _b2.end;
    if (!rangeStart || !rangeEnd)
      return;
    sortEventsIntoDateAndTimeGrids();
  }, [
    (_a = $app.calendarState.range.value) === null || _a === void 0 ? void 0 : _a.start,
    (_b = $app.calendarState.range.value) === null || _b === void 0 ? void 0 : _b.end,
    $app.calendarEvents.list.value
  ]);
  return u(g, { children: u(AppContext.Provider, { value: $app, children: u("div", { className: "sx__week-wrapper", id, children: [u("div", { className: "sx__week-header", children: u("div", { className: "sx__week-header-content", children: [u(DateAxis, { week: Object.values(week).map((day) => toJSDate(day.date)) }), u("div", { className: "sx__date-grid", "aria-label": $app.translate("Full day- and multiple day events"), children: Object.values(week).map((day) => u(DateGridDay, { calendarEvents: day.dateGridEvents })) }), u("div", { className: "sx__week-header-border" })] }) }), u("div", { className: "sx__week-grid", children: [u(TimeAxis, {}), Object.values(week).map((day) => u(TimeGridDay, { calendarEvents: day.timeGridEvents, date: day.date }, day.date + (/* @__PURE__ */ new Date()).getTime()))] })] }) }) });
};
var getRangeStartGivenDayBoundaries = (calendarConfig, date) => {
  return `${toDateString$1(date)} ${timeStringFromTimePoints(calendarConfig.dayBoundaries.start)}`;
};
var getRangeEndGivenDayBoundaries = (calendarConfig, date) => {
  let dayEndTimeString = timeStringFromTimePoints(calendarConfig.dayBoundaries.end);
  let newRangeEndDate = toDateString$1(date);
  if (calendarConfig.isHybridDay) {
    newRangeEndDate = addDays(newRangeEndDate, 1);
  }
  if (calendarConfig.dayBoundaries.end === 2400) {
    dayEndTimeString = "23:59";
  }
  return `${newRangeEndDate} ${dayEndTimeString}`;
};
var setRangeForWeek = (config) => {
  const weekForDate = config.timeUnitsImpl.getWeekFor(toJSDate(config.date));
  config.range.value = {
    start: getRangeStartGivenDayBoundaries(config.calendarConfig, weekForDate[0]),
    end: getRangeEndGivenDayBoundaries(config.calendarConfig, weekForDate[weekForDate.length - 1])
  };
};
var setRangeForMonth = (config) => {
  const { year, month } = toIntegers(config.date);
  const monthForDate = config.timeUnitsImpl.getMonthWithTrailingAndLeadingDays(year, month);
  const newRangeEndDate = toDateString$1(monthForDate[monthForDate.length - 1][monthForDate[monthForDate.length - 1].length - 1]);
  config.range.value = {
    start: toDateTimeString(monthForDate[0][0]),
    end: `${newRangeEndDate} 23:59`
  };
};
var setRangeForDay = (config) => {
  config.range.value = {
    start: getRangeStartGivenDayBoundaries(config.calendarConfig, toJSDate(config.date)),
    end: getRangeEndGivenDayBoundaries(config.calendarConfig, toJSDate(config.date))
  };
};
var viewWeek = createPreactView({
  name: InternalViewName.Week,
  label: "Week",
  Component: WeekWrapper,
  setDateRange: setRangeForWeek,
  hasSmallScreenCompat: false,
  hasWideScreenCompat: true,
  backwardForwardFn: addDays,
  backwardForwardUnits: 7
});
var createWeekForMonth = (week, day) => {
  week.push({
    date: toDateString$1(day),
    events: {}
  });
  return week;
};
var createMonth = (date, timeUnitsImpl) => {
  const { year, month: monthFromDate } = toIntegers(date);
  const monthWithDates = timeUnitsImpl.getMonthWithTrailingAndLeadingDays(year, monthFromDate);
  const month = [];
  for (const week of monthWithDates) {
    month.push(week.reduce(createWeekForMonth, []));
  }
  return month;
};
function MonthGridEvent({ gridRow, calendarEvent, date }) {
  const $app = P(AppContext);
  const { createDragStartTimeout, setClickedEventIfNotDragging } = useEventInteractions($app);
  const hasStartDate = dateFromDateTime(calendarEvent.start) === date;
  const nDays = calendarEvent._eventFragments[date];
  const eventCSSVariables = {
    borderLeft: hasStartDate ? `4px solid var(--sx-color-${calendarEvent._color})` : void 0,
    color: `var(--sx-color-on-${calendarEvent._color}-container)`,
    backgroundColor: `var(--sx-color-${calendarEvent._color}-container)`,
    // CORRELATION ID: 2 (10px subtracted from width)
    // nDays * 100% for the width of each day + 1px for border - 10 px for horizontal gap between events
    width: `calc(${nDays * 100 + "%"} + ${nDays}px - 10px)`
  };
  const handleStartDrag = (uiEvent) => {
    if (isUIEventTouchEvent(uiEvent))
      uiEvent.preventDefault();
    if (!uiEvent.target)
      return;
    if (!$app.config.plugins.dragAndDrop)
      return;
    $app.config.plugins.dragAndDrop.createMonthGridDragHandler(calendarEvent, $app);
  };
  const customComponent = $app.config._customComponentFns.monthGridEvent;
  const customComponentId = customComponent ? "custom-month-grid-event-" + randomStringId() : void 0;
  _(() => {
    if (!customComponent)
      return;
    customComponent(getElementByCCID(customComponentId), {
      calendarEvent: calendarEvent._getExternalEvent(),
      hasStartDate
    });
  }, []);
  const handleOnClick = (e) => {
    e.stopPropagation();
    invokeOnEventClickCallback($app, calendarEvent);
  };
  return u("div", { draggable: !!$app.config.plugins.dragAndDrop, "data-id": calendarEvent.id, "data-ccid": customComponentId, onMouseDown: (e) => createDragStartTimeout(handleStartDrag, e), onMouseUp: (e) => setClickedEventIfNotDragging(calendarEvent, e), onTouchStart: (e) => createDragStartTimeout(handleStartDrag, e), onTouchEnd: (e) => setClickedEventIfNotDragging(calendarEvent, e), onClick: handleOnClick, className: "sx__event sx__month-grid-event sx__month-grid-cell", style: {
    gridRow,
    width: eventCSSVariables.width,
    padding: customComponent ? "0px" : void 0,
    borderLeft: customComponent ? void 0 : eventCSSVariables.borderLeft,
    color: customComponent ? void 0 : eventCSSVariables.color,
    backgroundColor: customComponent ? void 0 : eventCSSVariables.backgroundColor
  }, children: !customComponent && u("div", { className: "sx__month-grid-event-title", children: calendarEvent.title }) });
}
var EVENT_LIMIT_CONFIG = 4;
function MonthGridDay({ day, isFirstWeek }) {
  const $app = P(AppContext);
  const nEventsInDay = Object.values(day.events).filter((event) => typeof event === "object" || event === DATE_GRID_BLOCKER).length;
  const getEventTranslationSingularOrPlural = (nOfAdditionalEvents) => {
    if (nOfAdditionalEvents === 1)
      return $app.translate("event");
    return $app.translate("events");
  };
  const handleClickAdditionalEvents = () => {
    if (!$app.config.views.find((view) => view.name === InternalViewName.Day))
      return;
    setTimeout(() => {
      $app.datePickerState.selectedDate.value = day.date;
      $app.calendarState.view.value = InternalViewName.Day;
    }, 250);
  };
  const dateClassNames = ["sx__month-grid-day__header-date"];
  const dayDate = toJSDate(day.date);
  if (isToday(dayDate))
    dateClassNames.push("sx__is-today");
  return u("div", { className: "sx__month-grid-day", "data-date": day.date, onClick: () => $app.config.callbacks.onClickDate && $app.config.callbacks.onClickDate(day.date), children: [u("div", { className: "sx__month-grid-day__header", children: [isFirstWeek ? u("div", { className: "sx__month-grid-day__header-day-name", children: getDayNameShort(dayDate, $app.config.locale) }) : null, u("div", { className: dateClassNames.join(" "), children: dayDate.getDate() })] }), u("div", { className: "sx__month-grid-day__events", children: Object.values(day.events).slice(0, EVENT_LIMIT_CONFIG).map((event, index) => {
    if (typeof event !== "object")
      return u("div", { className: "sx__month-grid-blocker sx__month-grid-cell", style: { gridRow: index + 1 } });
    return u(MonthGridEvent, { gridRow: index + 1, calendarEvent: event, date: day.date });
  }) }), nEventsInDay > EVENT_LIMIT_CONFIG ? u("button", { className: "sx__month-grid-day__events-more sx__ripple--wide", onClick: handleClickAdditionalEvents, children: `+ ${nEventsInDay - EVENT_LIMIT_CONFIG} ${getEventTranslationSingularOrPlural(nEventsInDay - EVENT_LIMIT_CONFIG)}` }) : null] });
}
function MonthGridWeek({ week, isFirstWeek }) {
  return u("div", { className: "sx__month-grid-week", children: week.map((day) => u(MonthGridDay, { day, isFirstWeek })) });
}
var positionInMonthWeek = (sortedEvents, week) => {
  const weekDates = Object.keys(week).sort();
  const firstDateOfWeek = weekDates[0];
  const lastDateOfWeek = weekDates[weekDates.length - 1];
  const occupiedLevels = /* @__PURE__ */ new Set();
  for (const event of sortedEvents) {
    const eventOriginalStartDate = dateFromDateTime(event.start);
    const eventOriginalEndDate = dateFromDateTime(event.end);
    const isEventStartInWeek = !!week[eventOriginalStartDate];
    let isEventInWeek = isEventStartInWeek;
    if (!isEventStartInWeek && eventOriginalStartDate < firstDateOfWeek && eventOriginalEndDate >= firstDateOfWeek) {
      isEventInWeek = true;
    }
    if (!isEventInWeek)
      continue;
    const firstDateOfEvent = isEventStartInWeek ? eventOriginalStartDate : firstDateOfWeek;
    const lastDateOfEvent = eventOriginalEndDate <= lastDateOfWeek ? eventOriginalEndDate : lastDateOfWeek;
    const eventDays = Object.values(week).filter((day) => {
      return day.date >= firstDateOfEvent && day.date <= lastDateOfEvent;
    });
    let levelInWeekForEvent;
    let testLevel = 0;
    while (levelInWeekForEvent === void 0) {
      const isLevelFree = eventDays.every((day) => {
        return !day.events[testLevel];
      });
      if (isLevelFree) {
        levelInWeekForEvent = testLevel;
        occupiedLevels.add(testLevel);
      } else
        testLevel++;
    }
    for (const [eventDayIndex, eventDay] of eventDays.entries()) {
      if (eventDayIndex === 0) {
        event._eventFragments[firstDateOfEvent] = eventDays.length;
        eventDay.events[levelInWeekForEvent] = event;
      } else {
        eventDay.events[levelInWeekForEvent] = DATE_GRID_BLOCKER;
      }
    }
  }
  for (const level of Array.from(occupiedLevels)) {
    for (const [, day] of Object.entries(week)) {
      if (!day.events[level]) {
        day.events[level] = void 0;
      }
    }
  }
  return week;
};
var positionInMonth = (month, sortedEvents) => {
  const weeks = [];
  month.forEach((week) => {
    const weekMap = {};
    week.forEach((day) => weekMap[day.date] = day);
    weeks.push(weekMap);
  });
  weeks.forEach((week) => positionInMonthWeek(sortedEvents, week));
  return month;
};
var MonthGridWrapper = ({ $app, id }) => {
  var _a, _b;
  const [month, setMonth] = p([]);
  _(() => {
    $app.calendarEvents.list.value.forEach((event) => {
      event._eventFragments = {};
    });
    const newMonth = createMonth($app.datePickerState.selectedDate.value, $app.timeUnitsImpl);
    setMonth(positionInMonth(newMonth, $app.calendarEvents.list.value.sort(sortEventsByStartAndEnd)));
  }, [
    (_a = $app.calendarState.range.value) === null || _a === void 0 ? void 0 : _a.start,
    (_b = $app.calendarState.range.value) === null || _b === void 0 ? void 0 : _b.end,
    $app.calendarEvents.list.value
  ]);
  return u(AppContext.Provider, { value: $app, children: u("div", { id, className: "sx__month-grid-wrapper", children: month.map((week, index) => u(MonthGridWeek, { week, isFirstWeek: index === 0 }, index + (/* @__PURE__ */ new Date()).getTime())) }) });
};
var viewMonthGrid = createPreactView({
  name: InternalViewName.MonthGrid,
  label: "Month",
  setDateRange: setRangeForMonth,
  Component: MonthGridWrapper,
  hasWideScreenCompat: true,
  hasSmallScreenCompat: false,
  backwardForwardFn: addMonths,
  backwardForwardUnits: 1
});
var DayWrapper = ({ $app, id }) => {
  return u(WeekWrapper, { "$app": $app, id });
};
var viewDay = createPreactView({
  name: InternalViewName.Day,
  label: "Day",
  setDateRange: setRangeForDay,
  hasWideScreenCompat: true,
  hasSmallScreenCompat: true,
  Component: DayWrapper,
  backwardForwardFn: addDays,
  backwardForwardUnits: 1
});
var createAgendaMonth = (date, timeUnitsImpl) => {
  const { year, month } = toIntegers(date);
  const monthWithDates = timeUnitsImpl.getMonthWithTrailingAndLeadingDays(year, month);
  return {
    weeks: monthWithDates.map((week) => {
      return week.map((date2) => {
        return {
          date: toDateString$1(date2),
          events: []
        };
      });
    })
  };
};
function MonthAgendaDay({ day, isActive, setActiveDate }) {
  const dayClasses = ["sx__month-agenda-day"];
  if (isActive)
    dayClasses.push("sx__month-agenda-day--active");
  return u("div", { className: dayClasses.join(" "), onClick: () => setActiveDate(day.date), children: [u("div", { children: toJSDate(day.date).getDate() }), u("div", { className: "sx__month-agenda-day__event-icons", children: day.events.slice(0, 3).map((event) => u("div", { style: {
    backgroundColor: `var(--sx-color-${event._color})`,
    filter: `brightness(1.6)`
  }, className: "sx__month-agenda-day__event-icon" })) })] });
}
function MonthAgendaWeek({ week, setActiveDate, activeDate }) {
  return u("div", { className: "sx__month-agenda-week", children: week.map((day, index) => u(MonthAgendaDay, { setActiveDate, day, isActive: activeDate === day.date }, index + day.date)) });
}
function MonthAgendaDayNames({ week }) {
  const $app = P(AppContext);
  const localizedShortDayNames = getOneLetterOrShortDayNames(week.map((day) => toJSDate(day.date)), $app.config.locale);
  return u("div", { className: "sx__month-agenda-day-names", children: localizedShortDayNames.map((oneLetterDayName) => u("div", { className: "sx__month-agenda-day-name", children: oneLetterDayName })) });
}
var getAllEventDates = (startDate, endDate) => {
  let currentDate = startDate;
  const dates = [currentDate];
  while (currentDate < endDate) {
    currentDate = addDays(currentDate, 1);
    dates.push(currentDate);
  }
  return dates;
};
var placeEventInDay = (allDaysMap) => (event) => {
  getAllEventDates(dateFromDateTime(event.start), dateFromDateTime(event.end)).forEach((date) => {
    if (allDaysMap[date]) {
      allDaysMap[date].events.push(event);
    }
  });
};
var positionEventsInAgenda = (agendaMonth, eventsSortedByStart) => {
  const allDaysMap = agendaMonth.weeks.reduce((acc, week) => {
    week.forEach((day) => {
      acc[day.date] = day;
    });
    return acc;
  }, {});
  eventsSortedByStart.forEach(placeEventInDay(allDaysMap));
  return agendaMonth;
};
function MonthAgendaEvent({ calendarEvent }) {
  const $app = P(AppContext);
  const { setClickedEvent } = useEventInteractions($app);
  const eventCSSVariables = {
    backgroundColor: `var(--sx-color-${calendarEvent._color}-container)`,
    color: `var(--sx-color-on-${calendarEvent._color}-container)`,
    borderLeft: `4px solid var(--sx-color-${calendarEvent._color})`
  };
  const customComponent = $app.config._customComponentFns.monthAgendaEvent;
  const customComponentId = customComponent ? "custom-month-agenda-event-" + calendarEvent.id : void 0;
  _(() => {
    if (!customComponent)
      return;
    customComponent(getElementByCCID(customComponentId), {
      calendarEvent: calendarEvent._getExternalEvent()
    });
  }, []);
  const onClick = (e) => {
    invokeOnEventClickCallback($app, calendarEvent);
    setClickedEvent(e, calendarEvent);
  };
  return u("div", { className: "sx__event sx__month-agenda-event", "data-ccid": customComponentId, style: {
    backgroundColor: customComponent ? void 0 : eventCSSVariables.backgroundColor,
    color: customComponent ? void 0 : eventCSSVariables.color,
    borderLeft: customComponent ? void 0 : eventCSSVariables.borderLeft,
    padding: customComponent ? "0px" : void 0
  }, onClick: (e) => onClick(e), children: !customComponent && u(g, { children: [u("div", { className: "sx__month-agenda-event__title", children: calendarEvent.title }), u("div", { className: "sx__month-agenda-event__time sx__month-agenda-event__has-icon", children: [u(TimeIcon, { strokeColor: `var(--sx-color-on-${calendarEvent._color}-container)` }), getTimeStamp(calendarEvent, $app.config.locale)] })] }) });
}
function MonthAgendaEvents({ events }) {
  const $app = P(AppContext);
  return u("div", { className: "sx__month-agenda-events", children: events.length ? events.map((event) => u(MonthAgendaEvent, { calendarEvent: event }, event.id)) : u("div", { className: "sx__month-agenda-events__empty", children: $app.translate("No events") }) });
}
var MonthAgendaWrapper = ({ $app, id }) => {
  var _a;
  const getMonth = () => positionEventsInAgenda(createAgendaMonth($app.datePickerState.selectedDate.value, $app.timeUnitsImpl), $app.calendarEvents.list.value.sort(sortEventsByStartAndEnd));
  const [agendaMonth, setAgendaMonth] = p(getMonth());
  _(() => {
    setAgendaMonth(getMonth());
  }, [$app.datePickerState.selectedDate.value]);
  const [activeDate, setActiveDate] = p($app.datePickerState.selectedDate.value);
  return u(AppContext.Provider, { value: $app, children: u("div", { id, className: "sx__month-agenda-wrapper", children: [u(MonthAgendaDayNames, { week: agendaMonth.weeks[0] }), u("div", { className: "sx__month-agenda-weeks", children: agendaMonth.weeks.map((week) => u(MonthAgendaWeek, { week, setActiveDate, activeDate })) }), u(MonthAgendaEvents, { events: ((_a = agendaMonth.weeks.flat().find((day) => day.date === activeDate)) === null || _a === void 0 ? void 0 : _a.events) || [] }, activeDate)] }) });
};
var viewMonthAgenda = createPreactView({
  name: InternalViewName.MonthAgenda,
  label: "Month",
  setDateRange: setRangeForMonth,
  Component: MonthAgendaWrapper,
  hasSmallScreenCompat: true,
  hasWideScreenCompat: false,
  backwardForwardFn: addMonths,
  backwardForwardUnits: 1
});
export {
  CalendarApp,
  createCalendar,
  createPreactView,
  setRangeForDay,
  setRangeForMonth,
  setRangeForWeek,
  viewDay,
  viewMonthAgenda,
  viewMonthGrid,
  viewWeek
};
//# sourceMappingURL=@schedule-x_calendar.js.map
