const getTimePointsPerPixel = ($app) => {
    return $app.config.timePointsPerDay / $app.config.weekOptions.gridHeight;
};

const DateFormats = {
    DATE_STRING: /^\d{4}-\d{2}-\d{2}$/,
    TIME_STRING: /^\d{2}:\d{2}$/,
    DATE_TIME_STRING: /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/,
};

class InvalidDateTimeError extends Error {
    constructor(dateTimeSpecification) {
        super(`Invalid date time specification: ${dateTimeSpecification}`);
    }
}

const toJSDate = (dateTimeSpecification) => {
    if (!DateFormats.DATE_TIME_STRING.test(dateTimeSpecification) &&
        !DateFormats.DATE_STRING.test(dateTimeSpecification))
        throw new InvalidDateTimeError(dateTimeSpecification);
    return new Date(Number(dateTimeSpecification.slice(0, 4)), Number(dateTimeSpecification.slice(5, 7)) - 1, Number(dateTimeSpecification.slice(8, 10)), Number(dateTimeSpecification.slice(11, 13)), // for date strings this will be 0
    Number(dateTimeSpecification.slice(14, 16)) // for date strings this will be 0
    );
};
const toIntegers = (dateTimeSpecification) => {
    const hours = dateTimeSpecification.slice(11, 13), minutes = dateTimeSpecification.slice(14, 16);
    return {
        year: Number(dateTimeSpecification.slice(0, 4)),
        month: Number(dateTimeSpecification.slice(5, 7)) - 1,
        date: Number(dateTimeSpecification.slice(8, 10)),
        hours: hours !== '' ? Number(hours) : undefined,
        minutes: minutes !== '' ? Number(minutes) : undefined,
    };
};

class NumberRangeError extends Error {
    constructor(min, max) {
        super(`Number must be between ${min} and ${max}.`);
        Object.defineProperty(this, "min", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: min
        });
        Object.defineProperty(this, "max", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: max
        });
    }
}

const doubleDigit = (number) => {
    if (number < 0 || number > 99)
        throw new NumberRangeError(0, 99);
    return String(number).padStart(2, '0');
};

const toDateString = (date) => {
    return `${date.getFullYear()}-${doubleDigit(date.getMonth() + 1)}-${doubleDigit(date.getDate())}`;
};
const toTimeString = (date) => {
    return `${doubleDigit(date.getHours())}:${doubleDigit(date.getMinutes())}`;
};
const toDateTimeString = (date) => {
    return `${toDateString(date)} ${toTimeString(date)}`;
};

const minuteTimePointMultiplier = 1.6666666666666667; // 100 / 60
const addTimePointsToDateTime = (dateTimeString, pointsToAdd) => {
    const minutesToAdd = pointsToAdd / minuteTimePointMultiplier;
    const jsDate = toJSDate(dateTimeString);
    jsDate.setMinutes(jsDate.getMinutes() + minutesToAdd);
    return toDateTimeString(jsDate);
};

const updateEventsList = ($app, calendarEvent, oldEventEnd, newEventEnd) => {
    const rrule = calendarEvent._getForeignProperties().rrule;
    calendarEvent.end = newEventEnd;
    if (rrule && $app.config.plugins.eventRecurrence) {
        $app.config.plugins.eventRecurrence.updateRecurrenceOnResize(calendarEvent.id, oldEventEnd, newEventEnd);
        return;
    }
    $app.calendarEvents.list.value = [...$app.calendarEvents.list.value];
};

class TimeGridEventResizer {
    constructor($app, calendarEvent, initialY, CHANGE_THRESHOLD_IN_TIME_POINTS, dayBoundariesDateTime) {
        Object.defineProperty(this, "$app", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: $app
        });
        Object.defineProperty(this, "calendarEvent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: calendarEvent
        });
        Object.defineProperty(this, "initialY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: initialY
        });
        Object.defineProperty(this, "CHANGE_THRESHOLD_IN_TIME_POINTS", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: CHANGE_THRESHOLD_IN_TIME_POINTS
        });
        Object.defineProperty(this, "dayBoundariesDateTime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: dayBoundariesDateTime
        });
        Object.defineProperty(this, "originalEventEnd", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastIntervalDiff", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "handleMouseMove", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (event) => {
                const pixelDiffY = event.clientY - this.initialY;
                const timePointsDiffY = pixelDiffY * getTimePointsPerPixel(this.$app);
                const currentIntervalDiff = Math.round(timePointsDiffY / this.CHANGE_THRESHOLD_IN_TIME_POINTS);
                const timeDidNotChange = currentIntervalDiff === this.lastIntervalDiff;
                if (timeDidNotChange)
                    return;
                this.lastIntervalDiff = currentIntervalDiff;
                this.setNewTimeForEventEnd(this.CHANGE_THRESHOLD_IN_TIME_POINTS * currentIntervalDiff);
            }
        });
        Object.defineProperty(this, "handleMouseUp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                this.$app.elements.calendarWrapper.removeEventListener('mousemove', this.handleMouseMove);
                if (this.$app.config.callbacks.onEventUpdate) {
                    this.$app.config.callbacks.onEventUpdate(this.calendarEvent._getExternalEvent());
                }
            }
        });
        this.setupEventListeners();
        this.originalEventEnd = this.calendarEvent.end;
    }
    setupEventListeners() {
        this.$app.elements.calendarWrapper.addEventListener('mousemove', this.handleMouseMove);
        document.addEventListener('mouseup', this.handleMouseUp, { once: true });
    }
    setNewTimeForEventEnd(pointsToAdd) {
        const endBeforeUpdate = this.calendarEvent.end;
        const newEnd = addTimePointsToDateTime(this.originalEventEnd, pointsToAdd);
        if (newEnd > this.dayBoundariesDateTime.end ||
            newEnd <= this.calendarEvent.start)
            return;
        updateEventsList(this.$app, this.calendarEvent, endBeforeUpdate, newEnd);
    }
}

var PluginName;
(function (PluginName) {
    PluginName["DragAndDrop"] = "dragAndDrop";
    PluginName["EventModal"] = "eventModal";
    PluginName["ScrollController"] = "scrollController";
    PluginName["EventRecurrence"] = "eventRecurrence";
    PluginName["Resize"] = "resize";
    PluginName["CalendarControls"] = "calendarControls";
})(PluginName || (PluginName = {}));

const getTimeGridDayWidth = ($app) => {
    return $app.elements.calendarWrapper.querySelector('.sx__time-grid-day').clientWidth;
};

const addDays = (to, nDays) => {
    const { year, month, date, hours, minutes } = toIntegers(to);
    const isDateTimeString = hours !== undefined && minutes !== undefined;
    const jsDate = new Date(year, month, date, hours !== null && hours !== void 0 ? hours : 0, minutes !== null && minutes !== void 0 ? minutes : 0);
    jsDate.setDate(jsDate.getDate() + nDays);
    if (isDateTimeString) {
        return toDateTimeString(jsDate);
    }
    return toDateString(jsDate);
};

class DateGridEventResizer {
    constructor($app, calendarEvent, initialX) {
        Object.defineProperty(this, "$app", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: $app
        });
        Object.defineProperty(this, "calendarEvent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: calendarEvent
        });
        Object.defineProperty(this, "initialX", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: initialX
        });
        Object.defineProperty(this, "dayWidth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "originalEventEnd", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "handleMouseMove", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (event) => {
                const xDifference = event.clientX - this.initialX;
                const daysToAdd = Math.floor(xDifference / this.dayWidth);
                this.setNewTimeForEventEnd(daysToAdd);
            }
        });
        Object.defineProperty(this, "handleMouseUp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                this.$app.elements.calendarWrapper.removeEventListener('mousemove', this.handleMouseMove);
                if (this.$app.config.callbacks.onEventUpdate) {
                    this.$app.config.callbacks.onEventUpdate(this.calendarEvent._getExternalEvent());
                }
            }
        });
        this.setupEventListeners();
        this.originalEventEnd = calendarEvent.end;
        this.dayWidth = getTimeGridDayWidth(this.$app);
    }
    setupEventListeners() {
        this.$app.elements.calendarWrapper.addEventListener('mousemove', this.handleMouseMove);
        document.addEventListener('mouseup', this.handleMouseUp, { once: true });
    }
    setNewTimeForEventEnd(daysToAdd) {
        const endBeforeUpdate = this.calendarEvent.end;
        const newEnd = addDays(this.originalEventEnd, daysToAdd);
        if (newEnd > this.$app.calendarState.range.value.end ||
            newEnd < this.calendarEvent.start ||
            newEnd <
                toDateString(toJSDate(this.$app.calendarState.range.value.start)))
            return;
        updateEventsList(this.$app, this.calendarEvent, endBeforeUpdate, newEnd);
    }
}

class ResizePluginImpl {
    constructor() {
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: PluginName.Resize
        });
        Object.defineProperty(this, "$app", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
    }
    init($app) {
        this.$app = $app;
    }
    createTimeGridEventResizer(calendarEvent, mouseDownEvent, dayBoundariesDateTime) {
        if (!this.$app)
            return this.logError();
        new TimeGridEventResizer(this.$app, calendarEvent, mouseDownEvent.clientY, 25, dayBoundariesDateTime);
    }
    createDateGridEventResizer(calendarEvent, mouseDownEvent) {
        if (!this.$app)
            return this.logError();
        new DateGridEventResizer(this.$app, calendarEvent, mouseDownEvent.clientX);
    }
    logError() {
        console.error('The calendar is not yet initialized. Cannot resize events.');
    }
}
const createResizePlugin = () => new ResizePluginImpl();

export { createResizePlugin };
